<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>node服务器部署https</title>
    <link href="/2017/01/17/2017-01-17-node-https/"/>
    <url>/2017/01/17/2017-01-17-node-https/</url>
    
    <content type="html"><![CDATA[<p>这个是16年年末时做的一项工作。随着苹果公司宣布在2017年后上架其商店的App，内部不得含有不安全的协议调用，换句话说，提供给app的接口调用，如http这样的，都必须使用安全的https协议。</p><p>https具体的概念，可以通过维基百科自行查询。本文主要介绍如何在node.js服务器上部署免费的https证书。关于本文用到的Let’s Encrypt证书签发服务，具体介绍可以在其官网上看。</p><!-- excerpt --><hr><h3 id="服务器私钥"><a href="#服务器私钥" class="headerlink" title="服务器私钥"></a>服务器私钥</h3><p>Let’s Encrypt服务需要在远程验证域名服务器的真实性，才会颁发证书。服务器需要提供唯一识别的密钥进行识别操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out ca-key.pem -des 4096<br></code></pre></td></tr></table></figure><p>这个操作为我们创建一个验证私钥，这时，这个私钥将会代表这台服务器对服务验证进行加密。创建时带-des，openssl要求填写密码。加密后，我们使用这个验证私钥验证证书时，都要输入密码。如果未来需要自动化更新证书有效期，为了简单，可以不设密码，去掉-des参数即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out server-key.pem 4096<br></code></pre></td></tr></table></figure><p>这次的操作与上一次雷同，区别在于这次的私钥将会用于产生服务公钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key server-key.pem -config openssl.cnf -out server-csr.pem<br></code></pre></td></tr></table></figure><p>在执行这个命令之前，我们要在当前目录创建一个配置文件，内容大概是域名主体信息，包括主体所在国家地区、所属公司组织或机构：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[req]</span><br>  <span class="hljs-attr">distinguished_name</span> = <span class="hljs-string">req_distinguished_name</span><br>  <span class="hljs-attr">req_extensions</span> = <span class="hljs-string">v3_req</span><br><br>  <span class="hljs-attr">[req_distinguished_name]</span><br>  <span class="hljs-attr">countryName</span> = <span class="hljs-string">Country Name (2 letter code)  </span><br>  <span class="hljs-attr">countryName_default</span> = <span class="hljs-string">CN  </span><br>  <span class="hljs-attr">stateOrProvinceName</span> = <span class="hljs-string">State or Province Name (full name)  </span><br>  <span class="hljs-attr">stateOrProvinceName_default</span> = <span class="hljs-string">Guangdong</span><br>  <span class="hljs-attr">localityName</span> = <span class="hljs-string">Locality Name (eg, city)  </span><br>  <span class="hljs-attr">localityName_default</span> = <span class="hljs-string">Guangzhou</span><br>  <span class="hljs-attr">organizationName</span> = <span class="hljs-string">Organization Name (eg, company)</span><br>  <span class="hljs-attr">organizationName_default</span> = <span class="hljs-string">Ghost Ltd.</span><br>  <span class="hljs-attr">organizationalUnitName</span>  = <span class="hljs-string">Organizational Unit Name (eg, section)  </span><br>  <span class="hljs-attr">organizationalUnitName_default</span> = <span class="hljs-string">Daily Task Project</span><br>  <span class="hljs-attr">commonName</span> = <span class="hljs-string">Common Name (e.g. server FQDN or YOUR name)</span><br>  <span class="hljs-attr">commonName_default</span> = <span class="hljs-string">ghold.bid</span><br>  <span class="hljs-attr">commonName_max</span>  = <span class="hljs-string">64</span><br>  <span class="hljs-attr">email</span> = <span class="hljs-string">Email Address</span><br>  <span class="hljs-attr">email_default</span> = <span class="hljs-string">gholdnet@gmail.com</span><br><br>  <span class="hljs-attr">[v3_req]</span>  <span class="hljs-string"></span><br><span class="hljs-comment">  # Extensions to add to a certificate request  </span><br>  <span class="hljs-attr">basicConstraints</span> = <span class="hljs-string">CA:FALSE  </span><br>  <span class="hljs-attr">keyUsage</span> = <span class="hljs-string">nonRepudiation, digitalSignature, keyEncipherment  </span><br>  <span class="hljs-attr">subjectAltName</span> = <span class="hljs-string">@alt_names  </span><br><br>  <span class="hljs-attr">[alt_names]</span>  <span class="hljs-string"></span><br><span class="hljs-comment">  # 注意这个设置，配置的域名将会被Let&#x27;s Encrypt服务逐个验证</span><br>  <span class="hljs-attr">DNS.1</span> = <span class="hljs-string">www.ghold.bid</span><br>  <span class="hljs-attr">DNS.2</span> = <span class="hljs-string">ghold.bid</span><br></code></pre></td></tr></table></figure><p>域名如需提供更多信息，可以找到<a href="http://web.mit.edu/crypto/openssl.cnf">配置模板</a>。</p><p>执行命令的结果是输出服务器公钥。有了<code>ca-key.pem</code>和<code>server-csr.pem</code>，执行Let’s Encrypt服务的第一步算是完成。</p><hr><h3 id="启动一个http服务用于验证"><a href="#启动一个http服务用于验证" class="headerlink" title="启动一个http服务用于验证"></a>启动一个http服务用于验证</h3><p>Let’s Encrypt服务证书签发协议使用ACME协议，即通过脚本生成验证文件到固定目录下，通过http的方式本地下载校验一次，通过http的方式远程下载校验一次。因此，我们必须要在指定的目录启动的http服务。即使在以后自动化更新证书有效期，也是需要启动http服务，要么就一直不关闭。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py<br></code></pre></td></tr></table></figure><p>先从脚本文件<code>acme_tiny.py</code>分析一下。这个脚本来自于<a href="https://github.com/diafygi/acme-tiny">Github</a>，为验证服务提供了整套流程，大大提高了部署效率。启动http服务的目标是为脚本提供临时验证文件的获取。在脚本中我们可以看到带有<code>.well-known/acme-challenge/</code>的目录。这个目录是不可以更改的，而且启动的http服务中必须包含这个目录路径。目的是可以通过<code>http://host/.well-known/acme-challenge/</code>下载到验证文件。还有一点是，端口必须是80端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m SimpleHTTPServer 80 # root user exec, python 2<br>python -m http.server 80 # root user exec, python 3<br></code></pre></td></tr></table></figure><p>如果要使用80端口，就要求我们拥有root的权限去启动这一步http服务。要么就是使用端口代理的方式，不过前提也是需要root配置代理，区别不大。</p><hr><h3 id="执行验证，生成签名，合成证书"><a href="#执行验证，生成签名，合成证书" class="headerlink" title="执行验证，生成签名，合成证书"></a>执行验证，生成签名，合成证书</h3><p>一切准备完毕后，就可以执行<code>acme_tiny.py </code>脚本生成签名。执行的代码在脚本注释里有写到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python acme_tiny.py --account-key ./ca-key.pem --csr ./server-csr.pem \<br>--acme-dir /path/to/.well-known/acme-challenge/ &gt; signed.crt<br></code></pre></td></tr></table></figure><p>生成<code>signed.crt</code>后，接下来是下载Let’s Encrypt服务提供的顶级证书，并加以合成。此步骤说明参看参考文档<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Let’s Encrypt，免费好用的 HTTPS 证书">[1]</span></a></sup></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem<br>cat signed.crt intermediate.pem &gt; chained.pem<br></code></pre></td></tr></table></figure><p>一般来说，使用node部署https需要的证书到这步即可。如果要执意使用OCSP Stapling请自行研究。</p><hr><h3 id="node部署与自动化更新"><a href="#node部署与自动化更新" class="headerlink" title="node部署与自动化更新"></a>node部署与自动化更新</h3><p><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="用Node.js创建自签名的HTTPS服务器">[2]</span></a></sup>在node启动时，加入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> options = &#123;<br>   <span class="hljs-attr">key</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;path/to/server-key.pem&#x27;</span>),<br>   <span class="hljs-attr">cert</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;path/to/chained.pem&#x27;</span>),<br>&#125;;<br>https.<span class="hljs-title function_">createServer</span>(options, app).<span class="hljs-title function_">listen</span>(settings.<span class="hljs-property">server_https_port</span>); <span class="hljs-comment">// 默认443</span><br></code></pre></td></tr></table></figure><p>由于大部分入口都会信任Let’s Encrypt提供的顶级证书，所以在浏览器上访问会自动安装我们的证书，从而不需要在使用api时做配置。</p><p><code>acme_tiny.py</code>中也提供了crontab定时任务方案，可以简单做点自动化更新证书，最后记得把证书放对位置，重启服务即可。</p><blockquote><p>参考文档：</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://imququ.com/post/letsencrypt-certificate.html">Let’s Encrypt，免费好用的 HTTPS 证书</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://cnodejs.org/topic/54745ac22804a0997d38b32d">用Node.js创建自签名的HTTPS服务器</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>TECHNIQUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NODEJS HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thrift实战两则</title>
    <link href="/2015/04/19/2015-04-19-thrift-experience/"/>
    <url>/2015/04/19/2015-04-19-thrift-experience/</url>
    
    <content type="html"><![CDATA[<p>我在一年前开始使用Thrift，契机是当时要开发一个后台内部数据查看工具。公司内部大多数系统都是使用Java作为主要语言，而我在毕业设计是对Java产生了厌恶，决心在未来应该尽可能远离Java开发（可惜事与愿违，现在已经成为职业Java开发）。那时我还是一个爱写小程序的测试工程师，比较偏向类似于Python、Javascript等等的“小语种”，这时，我遇到了Thrift。</p><!-- excerpt --><p><a href="http://thrift.apache.org/">Thrift</a>是由著名社交网站Facebook开发的开源软件框架，现在已加入到Apache孵化器中。以下引用官网对Thrift的定义：</p><blockquote><p>The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.</p></blockquote><p>经过学习发现，Thrift有两点适合我：一是，Thrift提供了生成器，可以简单生成接口服务代码，很适合懒人使用；二是，跨语言交互，能支持10多种语言进行通信，很多有趣的事情都可以简单做到。尤其是跨语言交互，利用服务化的接口建立不同语言间的服务端和客户端，只需要简单地实现接口，即可实现各种语言间的通讯。</p><hr><h3 id="Java与nodejs"><a href="#Java与nodejs" class="headerlink" title="Java与nodejs"></a>Java与nodejs</h3><p>工具是用来解决问题的，我认为选择合适的工具可以增添解决问题的趣味性。传统上，做一个接口查询Java后台的数据，有以下两种方法：对内使用struts＋Jsp的方式，对外使用webservice方式。前者使用一大堆action和占位符模版——一个字，累；后者使用冗长的xml作为通讯协议——两个字，乏味。Thrift则给了我一个简单有趣的解决方案。</p><p>先看以下的文本：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"># hello.thrift<br>service HelloService &#123;<br>  <span class="hljs-built_in">string</span> get<span class="hljs-constructor">HelloInterface(1:<span class="hljs-params">string</span> <span class="hljs-params">arg1</span>, 2:<span class="hljs-params">string</span> <span class="hljs-params">arg2</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是Thrift框架的原型接口文本，乍看这三行玩意不是能用的范。不过还需要进行加工，这时我们可以选择自己喜欢的语言：首先是服务端是Java无疑，毕竟是用Java写的后台；其次我选择了nodejs，因为当时在学习nodejs，进行点实践还是要的。</p><p>在Windows下，我们需要使用官方的thrift.exe对原型接口进行转化生成。在cmd中执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">thrift.exe <span class="hljs-literal">-r</span> <span class="hljs-literal">--gen</span> java hello.thrift<br>thrift.exe <span class="hljs-literal">-r</span> <span class="hljs-literal">--gen</span> js:node hello.thrift<br></code></pre></td></tr></table></figure><p>，在Mac中则是去掉.exe(前提是已经安装了Thrift，请自行官网找安装教程)，会分别产生两种语言的接口服务，均可以用来建立各自语言服务端和客户端。</p><h4 id="选择Java服务模型"><a href="#选择Java服务模型" class="headerlink" title="选择Java服务模型"></a>选择Java服务模型</h4><p>使用Thrift框架写服务端有以下流程：实现服务接口方法、定义处理器（处理方式）、定义传输方式、定义传输数据协议、组成服务端。而Thrift则提供了很多模型进行选择。服务器的模型会影响到数据传输方式、传输数据协议选择等通讯方式参数，具体方式请参考<a href="http://www.micmiu.com/soa/rpc/thrift-sample/">Thrift入门及Java实例演示</a>。当时我不想指定客户端的传输方式，所以选择了支持多线程的线程池服务模型。</p><p>按照入门里的说法，首先要实现了QueryService的接口方法，即工具的查询业务。在把方法嵌入模型中，启动服务端，一个简单的多线程socket服务端就架起了。</p><h4 id="架设nodejs客户端"><a href="#架设nodejs客户端" class="headerlink" title="架设nodejs客户端"></a>架设nodejs客户端</h4><p>服务端架起了总得有人用。Thrift的强大之一，是在于它提供了接口服务代码，客户端只需要知道服务模型，即可轻松接入。</p><p>上面使用的服务模型是传输方式为socket、传输数据协议是TBinaryProtocol。而我们将要使用的nodejs只需要以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> thrift = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;thrift&#x27;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">HelloService</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./gen-nodejs/HelloService.js&#x27;</span>),<br>  ttypes = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./gen-nodejs/hello_types.js&#x27;</span>);<br><br><span class="hljs-keyword">var</span> connection = thrift.<span class="hljs-title function_">createConnection</span>(<span class="hljs-variable constant_">IP</span>, <span class="hljs-variable constant_">PORT</span>),<br>  client = thrift.<span class="hljs-title function_">createClient</span>(<span class="hljs-title class_">HelloService</span>, connection);<br><br>connection.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>&#125;);<br><br>client.<span class="hljs-title function_">getHelloInterface</span>(arg1,arg2, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// to do something with res</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是thrift在nodejs中实现最简易客户端的写法，对于我要的业务查询功能已经足够。这时，我们已经轻松把Java桌上的数据，搬到nodejs上，接受下一步过滤和生成页面。</p><p>如果不包含业务代码，服务端与客户端代码总计不超过100行。接下来讲讲最近的另一次Thrift经历。</p><hr><h3 id="Java与Javascript"><a href="#Java与Javascript" class="headerlink" title="Java与Javascript"></a>Java与Javascript</h3><p>工作中总会遇到各种烦心事，譬如你把nodejs用得正欢时，突然被告知生产上的应用需要使用Jetty容器发布。Jetty是什么？Google一下发现原来是一个Java Http服务器和运行Java Servlet的容器。看到定义中带着一堆的Java，不禁黯然，果然后来发现上面只兼容Java的服务！（当时我马上发出感概，Docker会流行起来，这应该是间接原因。）这意味着我必须放弃依靠操作系统的nodejs。但是，我不想把前端的一些生成器和过滤器给丢了，我想，总有办法可以解决。没错，强大的Thrift又再次带来惊喜。</p><p>nodejs其实上是封装了Google开发的V8-Javascript处理器，也就是说，写的代码用的也是Javascript语言。在cmd中执行以下脚本，可以迅速产生对应的Javacript服务接口：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">thrift.exe <span class="hljs-literal">-r</span> <span class="hljs-literal">--gen</span> js hello.thrift<br></code></pre></td></tr></table></figure><p>产生的js文件只要在页面上进行引用，就可以方便地使用Thrift客户端功能（Javascript上只提供客户端功能）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/thrift.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/gen-js/HelloService.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="变更Java服务模型"><a href="#变更Java服务模型" class="headerlink" title="变更Java服务模型"></a>变更Java服务模型</h4><p>值得注意的是，使用Javascript作为客户端，传输方式和传输数据协议都没有Java和nodejs丰富。如传输方式只支持XMLHttpRequest（XHR）和webSocket，而对于查询的功能，使用XHR进行异步调用即可；而传输数据协议貌似只有JSON的协议（源码中注释有TBinaryProtocol，不过没有看到实现）。这样，之前的多线程Socket服务模型就玩不转了，只能把服务端重构一下。</p><p>由于传输方式变成了XHR方式，那么服务端也要变成可以提供Http服务。Thrift提供了对Java内置HttpServlet的扩展，这次就用这个技术产生一个Thrift的服务端。不过我会做得扩展性更好（<a href="">原文</a>）：</p><p>首先是实现处理接口，这个可以重用之前实现HelloService.Iface的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HelloHandler.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span>.Iface &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHelloInterface</span><span class="hljs-params">(String arg1, String arg2)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是实现处理方式，这里为了以后扩展多种处理接口，使用多重处理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HelloProcessor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HelloService</span>.Processor&lt;HelloHandler&gt; &#123;<br>    <span class="hljs-keyword">private</span> HelloHandler handler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloProcessor</span><span class="hljs-params">(HelloHandler iface)</span>&#123;<br>        <span class="hljs-built_in">super</span>(iface);<br>        handler = iface;<br>    &#125;<br>    <span class="hljs-keyword">public</span> HelloHandler <span class="hljs-title function_">getHandler</span><span class="hljs-params">()</span>&#123; <span class="hljs-keyword">return</span> handler;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHandler</span><span class="hljs-params">(HelloHandler handler)</span>&#123;<span class="hljs-built_in">this</span>.handler = handler;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ApiMultiplexingProcessor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiMultiplexingProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TMultiplexedProcessor</span> &#123;<br>    HelloHandler helloHandler;<br>    <span class="hljs-keyword">private</span> HelloProcessor helloProcessor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApiMultiplexingProcessor</span><span class="hljs-params">(HelloProcessor helloProcessor)</span>&#123;<br>        <span class="hljs-built_in">this</span>.registerProcessor(<span class="hljs-string">&quot;HelloService&quot;</span>, helloProcessor);<br>        helloHandler = helloProcessor.getHandler();<br>    &#125;<br>    <span class="hljs-keyword">public</span> HelloHandler <span class="hljs-title function_">getHelloHandler</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> helloHandler;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHelloHandler</span><span class="hljs-params">(HelloHandler helloHandler)</span> &#123;<br><span class="hljs-built_in">this</span>.helloHandler = helloHandler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是创建Servlet，这时要指定传输数据协议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApiServlet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiMultiplexingProcessor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloProcessor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloHandler</span>())), <span class="hljs-keyword">new</span> <span class="hljs-title class_">TJSONProtocol</span>.Factory());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，只要在Jetty上发布这个Servlet，就可以让客户端访问了。</p><p>也许还有个问题是，这里少了传输方式？其实Servlet已经指定了传输方式是Http，如果有兴趣，可以自行定制。</p><h3 id="Javascript客户端"><a href="#Javascript客户端" class="headerlink" title="Javascript客户端"></a>Javascript客户端</h3><p>使用Javascript编写Thrift客户端，需要进行以下几步（也可参看介绍服务端模型时的文章）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建Transport，默认是XHR传输方式：</span><br><span class="hljs-keyword">var</span> transport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thrift</span>.<span class="hljs-title class_">Transport</span>(<span class="hljs-string">&quot;./apiServlet&quot;</span>);<br><br><span class="hljs-comment">// 基于Transport创建Protocol，由于服务端使用的是多重服务，</span><br><span class="hljs-comment">// 这里的协议也是要支持多重服务协议，而数据协议默认是TJSONProtocol</span><br><span class="hljs-keyword">var</span> protocol = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thrift</span>.<span class="hljs-title class_">MultiplexProtocol</span>(<span class="hljs-string">&quot;HelloService&quot;</span>, transport);<br><br><span class="hljs-comment">// 基于Transport和Protocol创建 Client，这里没有指定Transport的原因是上一步已经指定：</span><br><span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloServiceClient</span>(protocol);<br><br><span class="hljs-comment">// 调用Client的相应方法</span><br>client.<span class="hljs-title function_">getHelloInterface</span>(arg1, args2, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)&#125;);<br></code></pre></td></tr></table></figure><p>完成以上几步，Javascript的Thrift客户端就完成了，剩下只需要把nodejs上的生成器和过滤器移植过来，启动客户端即可。</p><hr><h3 id="强大的扩展性"><a href="#强大的扩展性" class="headerlink" title="强大的扩展性"></a>强大的扩展性</h3><p>我觉得Thrift最强大的地方是简易扩展性。</p><h4 id="例一：加方法"><a href="#例一：加方法" class="headerlink" title="例一：加方法"></a>例一：加方法</h4><p>需求是要在HelloService加一个getWorldInterface方法。</p><p>只需：</p><ol><li><p>在hello.thrift中加一行：</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># hello.thrift<br>service HelloService &#123;<br><span class="hljs-built_in">string</span> get<span class="hljs-constructor">HelloInterface(1:<span class="hljs-params">string</span> <span class="hljs-params">arg1</span>, 2:<span class="hljs-params">string</span> <span class="hljs-params">arg2</span>)</span>,<br><span class="hljs-built_in">string</span> get<span class="hljs-constructor">WorldInterface(1:<span class="hljs-params">string</span> <span class="hljs-params">arg1</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重新生成接口代码，并替换掉原来的；</p></li><li><p>服务端与客户端都实现一下新增的接口方法即可。</p></li></ol><h4 id="例二：加接口"><a href="#例二：加接口" class="headerlink" title="例二：加接口"></a>例二：加接口</h4><p>需求是要加一个WorldService接口，并且有一个getWorldInterface方法</p><p>只需：</p><ol><li><p>在hello.thrift中加一个service：</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># hello.thrift<br>service HelloService &#123;<br><span class="hljs-built_in">string</span> get<span class="hljs-constructor">HelloInterface(1:<span class="hljs-params">string</span> <span class="hljs-params">arg1</span>, 2:<span class="hljs-params">string</span> <span class="hljs-params">arg2</span>)</span><br>&#125;<br>service WorldService &#123;<br><span class="hljs-built_in">string</span> get<span class="hljs-constructor">WorldInterface(1:<span class="hljs-params">string</span> <span class="hljs-params">arg1</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重新生成接口代码，把WorldService代码加入到应用中；</p></li><li><p>在多重服务TMultiplexedProcessor中注册新的接口方式（实战一需要改进processor为TMultiplexedProcessor，实战二中只需添加Handler和注册）；</p></li><li><p>客户端对指定的接口进行调用，如改变nodejs下的create方法和javascript下的protocol定义</p></li></ol><p>如上，大概4步即可扩展一个新的接口。</p><hr><p>总结一下，以上是个人使用Thrift工作时的经验，不过我觉得Thrift是深坑，准备使用更多的语言去玩一玩。下一步应该是写个Python或者Go的客户端，如果有新东西在分享吧。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TECHNIQUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>THRIFT JAVA NODEJS JAVASCRIPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>D3矩阵数据展示</title>
    <link href="/2015/03/24/2015-03-24-d3-matrix/"/>
    <url>/2015/03/24/2015-03-24-d3-matrix/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="http://bost.ocks.org/mike/path/">Path Transitions</a>，感谢</p></blockquote><p>当我们要实现一个以时间划分的实时演变动画，我们经常会使用时间标记x轴：随着时间演进，新的数据会从右侧进入，老的数据会从左侧退出。如果我们直接使用D3内置的路径插值器，我们可能会看到一个奇怪的抖动动画：</p><!-- excerpt --><link rel="stylesheet" href="/assets/css/d3_directed_edge/default.css"><div id="chart1"></div><script type="text/javascript" src="/assets/js/d3_directed_edge/example_2.js" ></script>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>D3路径动画</title>
    <link href="/2015/03/19/2015-03-19-d3-path-transitions/"/>
    <url>/2015/03/19/2015-03-19-d3-path-transitions/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="http://bost.ocks.org/mike/path/">Path Transitions</a>，感谢</p></blockquote><p>当我们要实现一个以时间划分的实时演变动画，我们经常会使用时间标记x轴：随着时间演进，新的数据会从右侧进入，老的数据会从左侧退出。如果我们直接使用D3内置的路径插值器，我们可能会看到一个奇怪的抖动动画：</p><!-- excerpt --><link rel="stylesheet" href="/assets/css/d3_path_transitions/default.css"><script type="text/javascript" src="/assets/js/d3_path_transitions/share.js" ></script><link href="/assets/css/metro.min.css" rel="stylesheet"><link rel="stylesheet" href="/assets/css/default.css"><link href="/assets/css/petty_colors.css" rel="stylesheet"><p><example_1></example_1></p><script type="text/javascript" src="/assets/js/d3_path_transitions/example_1.js" ></script><p>实际上，在对两条路径进行插值时，有多种有效的理解。一种理解是在不变x轴点上修改y的值；另一种是理解是随时间的变化可以呈现一个以x轴为引导的推拉窗效果。第二种是我们想要的方式，但我们怎样告诉D3在x轴上插值而不是在y轴上插值呢？</p><p>首先，我们需要知道SVG上怎样展示路径。考虑下面这个画了个带三点的折线路径元素：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M0,0L1,6L2,4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br></code></pre></td></tr></table></figure><p>路径的数据会存入d这个属性中，由点移动（M）和线连接（L）组成。如上面的路径描述的是从(0, 0)坐标开始，画一条直线到(1, 6)，再从(1, 6)画一条直线到(2, 4)。这些坐标点都称为控制点。现在我们打算更新为以下的路径：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M0,6L1,4L2,5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br></code></pre></td></tr></table></figure><p>旧的路径有3个控制点，新的也有3个，所以最简单的插值法是每个对应的控制点各自进行插值。</p><ul><li>(0, 0) ↦ (0, 6)</li><li>(1, 6) ↦ (1, 4)</li><li>(2, 4) ↦ (2, 5)</li></ul><p>因为只有坐标y的值变化了，这个插值的效果会是一个垂直的抖动。当你告诉D3去转换这两条路径，D3会找到内嵌在path元素中的数字，并且按顺序配对，进而进行插值操作。这样，D3将会在三个控制点——六个数字上进行插值，最后的结果跟开始那个图表是一样的摆动。</p><p>为了消除摆动，得通过对变换进行插值的方式，而不是通过对路径进行插值的方式。我们换种思路，假设我们的数据已经是固定的了，我们只是一直在展示这个表格的不同部分。配置刷动的速率与新数据到达的速率一样，我们就可以无缝地展示一个实时数据：</p><p><example_2></example_2></p><script type="text/javascript" src="/assets/js/d3_path_transitions/example_2.js" ></script><p>当接收到一个新数据，我们会立即重新画这条线，并且去除先前的所有变换。这时，新数据会隐藏在图表的右侧。接着，我们左移这条线，使得看上去像是滑动的。</p><p>尽管概念上很简单，但是这个方法有需要注意的地方：</p><p>首先，我们需要使用线性调节的方式，这样持续变换的速度才能维持不变。如果使用默认三次方的速度调节，那么转变速度会振荡，线条也会不停摆动。<br>其次，由于进入的数据会先画在图表右侧外，要实现的话，需要设置显示的泳道。譬如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">clipPath</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clip&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;950&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">clipPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后，如果我们使用的是样条插值器，那么会发现新增的数据点会改变前一点的切线和整个线段的轮廓。为了避免关键点改变时产生的额外抖动，需要进一步限制可视范围，隐藏额外的控制点。</p><p><example_3></example_3></p><script type="text/javascript" src="/assets/js/d3_path_transitions/example_3.js" ></script><p>以下例子将结合内建的坐标轴模块和时间刻度模块，展示最近三分钟内阅读这篇文章的滚屏活动情况。<br><example_4></example_4></p><script type="text/javascript" src="/assets/js/d3_path_transitions/example_4.js" ></script><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>D3转变器详解</title>
    <link href="/2015/02/07/2015-02-07-d3-transition/"/>
    <url>/2015/02/07/2015-02-07-d3-transition/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="http://bost.ocks.org/mike/transition/">Working with Transitions</a>，感谢</p></blockquote><p>D3使用selection.transition可以在改变DOM时简单实现动画的效果。举个简单的例子，实现一个改变页面字体颜色的代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;body&quot;</span>).<span class="hljs-title function_">style</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果加上变换及变化的时长，一个简单的字体变颜色的动画就有了（默认为黑色）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;body&quot;</span>).<span class="hljs-title function_">transition</span>().<span class="hljs-title function_">duration</span>(<span class="hljs-number">2000</span>).<span class="hljs-title function_">style</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);<br></code></pre></td></tr></table></figure><p>以下开始了解转变的细节。</p><!-- excerpt --><hr><h3 id="转变器是一种动画形式"><a href="#转变器是一种动画形式" class="headerlink" title="转变器是一种动画形式"></a>转变器是一种动画形式</h3><p>转变器是一种只有起点与终点两个关键帧的限制型关键帧动画过程。起点关键帧描述的是当前DOM的状态，而终点关键帧则是我们提供的一系列变化后的属性、样式和特性。</p><p>在一些情况下，开始的关键帧状态并不是我们想要的情况。譬如<code>red</code>这个字符串会被解释为<code>rgb(255,0,0)</code>。又如，<code>rgba(255,0,0,0)</code>这个颜色，是一个显示为透明的红色。但如果使用RGB的内插器，则会认为是一个<code>rgb(255,0,0)</code>，一个标准的不透明红色。</p><p>这个时候，我们可以自定义起点关键帧的状态。方法一是在创建转变器前定义起点关键帧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;body&quot;</span>)<br>    .<span class="hljs-title function_">style</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>)<br>    .<span class="hljs-title function_">transition</span>()<br>    .<span class="hljs-title function_">style</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);<br></code></pre></td></tr></table></figure><p>不过这种方法只是保持属性值是一致的，并没有解决属性值转换的问题。方法二是提供起点状态和终点状态，同时提供一个指定的内插器，保证转换也是一致的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;body&quot;</span>)<br>.<span class="hljs-title function_">transition</span>()<br>    .<span class="hljs-title function_">styleTween</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> d3.<span class="hljs-title function_">interpolate</span>(<span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>transition.styleTween可以自定义一个样式内插器，这个内插器会使用已知的CSS3样式转换语法。</p><hr><h3 id="随时间进行插值"><a href="#随时间进行插值" class="headerlink" title="随时间进行插值"></a>随时间进行插值</h3><p>如果要实现一个圆滑的动画，D3需要知道如何使用插值的方式，从起点状态演变到对应的终点状态。d3.interpolate方法通过推断起点状态与终点状态中每个值对的类型，确定了一个合适的插值器。D3支持以下几种类型：</p><ul><li>数字（numbers）</li><li>颜色（colors）</li><li>几何变换（geometric transforms）</li><li>内嵌数字的字符串（如”96px”）</li></ul><p>字符串插值器会配对起点状态的字符串值和终点状态的字符串值，并分离出数字部分进行插值处理后，再拼凑到非数字部分上完成插值的重建。各种复杂的场景都可以应用，如路径数据<code>&quot;M0,0L20,30&quot;</code>、CSS的字体样式<code>&quot;300 12px/100% Helvetica&quot;</code>。</p><p>不过字符串插值器并不是万能的。如果起点状态的字符串值格式不能跟终点状态的对上，那么就不能分离出数字部分了。这个时候需要重新对状态进行采样或提供更多使两者融合的算法。譬如，生成弧时我们需要使用极坐标的插值器，这样就可以通过角度进行插值，而不是通过点的位置。</p><p>现在回到标题中“随时间“理解。实际上，当我们需要自定义插值器时，被定义的插值器要返回一个以时间t为参数，定义域为[0, 1]的子处理器。这样的一个插值器，当t为0时，返回的是起点状态的值；当t为1时，返回的是终点状态的值；当0&lt;t&lt;1时，返回一个混合值（其实我觉得只要任意定义域里的t，函数都有返回值应该就可以了）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">interpolateNumber</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + t * (b - a);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一点需要注意的是，当从0开始插值，或插值到0，会遇到一些很小的数，譬如0.0000001。官方教程中这里说最小值只能到0.000001，原因是0.0000001会被转换为<code>1e－7</code>，而CSS会解析为1。但我测试过，现在的CSS是可以使用<code>1e－8</code>甚至更小。</p><hr><h3 id="有些情况是不能被插值的"><a href="#有些情况是不能被插值的" class="headerlink" title="有些情况是不能被插值的"></a>有些情况是不能被插值的</h3><p>在用选择器改变DOM时，是不能进行插值处理的，也就是说，只能使用转变器演进动画过程。譬如，我们不能对创建元素这个变化进行插值。更深的原因是，设计一个转变器的前提，对象元素必须要是存在的。这样，元素创建这个状态是不能成为起点状态。选择器的相关方法，如数据绑定（data、enter、exit），和元素创建（append、insert），只能通过选择器实现，不能使用转变器实现。</p><p>以下代码会经常用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//绑定数据</span><br><span class="hljs-keyword">var</span> bar = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;.bar&quot;</span>)<br>    .<span class="hljs-title function_">data</span>(data, <span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>) &#123; <span class="hljs-keyword">return</span> d.<span class="hljs-property">key</span>; &#125;);<br><br><span class="hljs-comment">//给enter选择器的元素进行初始化</span><br>bar.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;rect&quot;</span>)<br>    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>)<br>    <span class="hljs-comment">//…</span><br><br><span class="hljs-comment">//对enter和update选择器的元素设计转变器</span><br>bar.<span class="hljs-title function_">transition</span>()<br><br><span class="hljs-comment">//对exit选择器设计退出的转变器，最后要删除元素</span><br>bar.<span class="hljs-title function_">exit</span>().<span class="hljs-title function_">transition</span>()<br>    <span class="hljs-comment">//…</span><br>    .<span class="hljs-title function_">remove</span>();<br></code></pre></td></tr></table></figure><p>为方便起见，针对以上规则有一些例外的情况。如上面代码exit的例子，可以使用transition.remove在转变结束时删除转变的元素。还有就是，transition.text可以在转变开始时设定元素的文本内容。在将来，还可能支持其他不可插值操作，如classed和html。</p><hr><h3 id="转变器的生命周期"><a href="#转变器的生命周期" class="headerlink" title="转变器的生命周期"></a>转变器的生命周期</h3><p>转变器比较棘手的部分是，它会随时间发生而不是马上完成。转变器并不是运行在一条简单的路线上，一旦页面进行加载，就会产生一系列复杂的反复回调。如果我们想在设计时忽略转变器运行过程的复杂性，我们必须理解转变器整个计算过程中的规则。</p><p>转变器有一个四阶段的生命周期：</p><ol><li>调度阶段</li><li>开始阶段</li><li>运行阶段</li><li>结束阶段</li></ol><p>转变器在selection.transition被调用时会进入调度阶段。我们会在这个阶段通过转变器的attr、style和其他转变器方法设置终点关键帧的状态。整个调度过程是发生在代码中，如作为点击某个按钮的响应等等，这意味着这个阶段是同步进行的。这种方式使得更容易调试，更容易根据全局变化的状态配置终点关键帧的状态。</p><p>在调度阶段，我们可以选择性配置一个延迟时间（delay），而我们的开始阶段正是根据我们配置的延迟时间开始的。当没有配置延迟时间时，开始阶段会以最快的方式进入开始阶段。一旦进入开始阶段，start事件会被触发，这时转变器会异步初始化它的子处理器（tween）。这些处理器会分别从DOM中收集起点的状态值和构建插值器。由于在转变器进入开始阶段前，是无法明确知道起点的状态值，因此定义子处理器的初始化工作是很必要的。还要注意的是，我们使用attrTween、styleTween和其他tween方法时，需要设计成在转变器进入开始阶段时可以异步计算的。</p><p>当进入运行阶段，转变器的子处理器会分别以t参数从0到1开始执行。延迟时间（delay）也会影响从调度阶段到运行阶段的时长，而执行时间（duration）的配置则会影响整个运行阶段的时长。利用这两个方法，可以简单地调节转变器的时间流，譬如我们可以实现缓进缓出的效果。所以，整个转变器的时长是延迟时间加上执行时间，一旦到时间就会结束，即进入结束阶段。</p><p>进入结束阶段，这意味着子处理器都执行了t&#x3D;1的情况，并且会触发end事件。</p><hr><h3 id="转变器是针对每个元素，并且是独占的。"><a href="#转变器是针对每个元素，并且是独占的。" class="headerlink" title="转变器是针对每个元素，并且是独占的。"></a>转变器是针对每个元素，并且是独占的。</h3><p>每个元素的转变器都是独立运行的。当我们为一个选择器创建了一个转变器，那是我们为选择器中的每个元素创建了一系列的选择器，而不是为多个元素创建了一个混合转变器。不同的元素可以使用不同的延迟时间和执行时间，甚至可以使用不同的调节和不同的子处理器。另外，转变器中的事件也是分别分发给每个元素的。当某个元素接收到了一个结束事件，那么这个元素的转变会结束，但转变器中的其他元素可能还在运行。</p><p>对于任意一个元素，只能同时运行一个转变器。如果要在这个元素上执行一个新的转变器，那么会停止这个元素上正在运行的转变器。中断一个元素上的转变器运行，不会影响到其他元素，也就是说，多种转变器是可以同时运行在不同的元素上的。在一个转变器在运行同时，可以使用transition.transition安排多个其他的转变器准备执行。</p><p>对于每个元素，转变器队列是个先进先出的结构。当转变器进入调度阶段时，会得到一个自增的id。当元素上一个转变器开始执行，那么只有比这个转变器更新的转变器才能被执行。也就是说，在旧的转变器执行过程中，插入启动其他转变器都会马上取消所有旧队列中的所有转变器，建立新的队列，即使旧队列中的转变器还没进入开始阶段。这种方式消除主动取消转变器的必要。</p><p>类似于数据绑定中，数据会绑定到元素的<code>__data__</code>属性上，转变器也会绑定到元素的<code>__transition__</code>属性上。当转变器进入调度阶段，属性会被创建；当最后调度的转变器执行结束，这个属性就会被删除。在控制台上对这个属性上打上标记，可以有效调试哪个转变器安排在哪个元素。由于转变器是绑定到元素上的，我们可以重新选择元素，修改子处理器和时间流。这个普遍应用在组件驱动的转变器上，譬如坐标轴组件。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>D3对象连贯性教程里的知识点</title>
    <link href="/2015/02/01/2015-02-01-d3-object-constancy/"/>
    <url>/2015/02/01/2015-02-01-d3-object-constancy/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="http://bost.ocks.org/mike/constancy/">Object Constancy</a>，感谢</p></blockquote><p>对象连贯性（Object Constancy），在教程中的解释为：呈现某种特定数据的图形元素可以通过变换的方式捕捉可视化的轨迹，也就是变换之间的显示是连贯的。</p><!-- excerpt --><link rel="stylesheet" href="/assets/css/d3_object_constancy/default.css"><p id = "chart"></p><p id="menu"><b>Top States by Age Bracket, 2008</b><br>Age: <select></select></p><script type="text/javascript" src="/assets/js/d3_object_constancy/share.js" ></script><link href="/assets/css/metro.min.css" rel="stylesheet"><link rel="stylesheet" href="/assets/css/default.css"><link href="/assets/css/petty_colors.css" rel="stylesheet"><p>以下介绍这个例子中有趣的知识点：</p><hr><h3 id="D3数值格式化"><a href="#D3数值格式化" class="headerlink" title="D3数值格式化"></a>D3数值格式化</h3><p>d3.format()返回一个format指示符，用于数值格式化使用。接受的参数如下格式：</p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[​<span class="hljs-comment">[fill]</span>align]</span><span class="hljs-comment">[sign]</span><span class="hljs-comment">[symbol]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[width]</span><span class="hljs-comment">[,]</span><span class="hljs-comment">[.precision]</span><span class="hljs-comment">[type]</span><br></code></pre></td></tr></table></figure><ul><li>fill：需要跟align一起使用。指定字符用于填充align对齐后的空间，字符不能是<code>&#123;</code>或<code>&#125;</code>。</li><li>align：指定格式的对齐方式，<code>&gt;</code>为右对齐（默认），<code>&lt;</code>为左对齐，<code>^</code>为居中对齐，空位由fill填充。</li><li>sign：指定是否显示正负号。<code>+</code>为正数时显示正号，负数时显示负号；<code>-</code>为正数时不显示正号，负数时显示负号（默认）；<code> </code>（空格）为正数时显示空格，负数时显示负号。</li><li>symbol：指定货币或进制的前后缀。<code>$</code>为要加上货币标志，<code>#</code>为要在进制类型时加上进制的前缀。</li><li>0：开启0字符填充。</li><li>width：限制内容宽度。不设置则宽度由内容定。</li><li>,（逗号）：启用千位逗号分隔功能。</li><li>.precision：指定小数的精度。precision表示保留的位数。</li><li>type：指定数值转换的结果类型。<ul><li><code>e</code>：科学计数法。</li><li><code>g</code>：通用模式。保证有效数字数。</li><li><code>f</code>：固定值模式。固定小数位数为精度数，可以把科学计数转换为长数字形式。</li><li><code>d</code>：整数模式。只能对正数进行格式化。</li><li><code>r</code>：如果整数部分长度大于精度数，则保留精度数的位数，其余用0代替。</li><li><code>%</code>：跟固定值模式一致。先乘以100，再加上<code>%</code>后缀</li><li><code>p</code>：跟<code>r</code>一致。先乘以100，再加上<code>%</code>后缀</li><li><code>b</code>：二进制。</li><li><code>o</code>：八进制。</li><li><code>x</code>：十六进制。大于9的字母使用小写。</li><li><code>X</code>：十六进制。大于9的字母使用大写。</li><li><code>c</code>：字节码。不太明白。</li><li><code>s</code>：通过<code>r</code>模式转换，转换为带计量单位的。</li><li><code>n</code>：与<code>,g</code>一样。</li></ul></li></ul><h3 id="线性还是离散？"><a href="#线性还是离散？" class="headerlink" title="线性还是离散？"></a>线性还是离散？</h3><p><code>d3.scale.linear()</code>与<code>d3.scale.ordinal()</code>分别代表着刻度运算中的线性映射与离散映射。两者都会接受domain与range，分别在数学中称为定义域和值域。</p><p>linear会根据定义域[a, b]和值域[c, d]有</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">ax + <span class="hljs-attr">y</span> = c<br>bx + <span class="hljs-attr">y</span> = d<br></code></pre></td></tr></table></figure><p>这样就可以分别计算出</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> (d-c)/(b-a)<br><span class="hljs-attribute">y</span> <span class="hljs-operator">=</span> c - a(d-c)/(b-a)<br></code></pre></td></tr></table></figure><p>所以对于任意在定义域中的数值z都可以计算出结果为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">z(d-c)/(<span class="hljs-selector-tag">b</span>-<span class="hljs-selector-tag">a</span>) + c - <span class="hljs-selector-tag">a</span>(d-c)/(<span class="hljs-selector-tag">b</span>-<span class="hljs-selector-tag">a</span>)<br></code></pre></td></tr></table></figure><p>ordinal接受的定义域是离散的。譬如例子中的州名称分类。虽然我们在分析例子源码时发现值域类似linear的，放入[c, d]这样的连续集合，但是ordinal的内部值域分解机制会散列这个连续集合。以rangeBands为例，会产生离散的间隔带，设定义域中元素个数为x，离散内间隔系数为k，外间隔系数为l，则有</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">w + <span class="hljs-attr">ks</span> = s<br>xs + <span class="hljs-number">2</span><span class="hljs-attr">ls</span> = d-c<br></code></pre></td></tr></table></figure><p>其中w为带宽，s为步长，结果为</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">s = <span class="hljs-comment">(d-c)</span>/<span class="hljs-comment">(x+2l)</span><br>w = <span class="hljs-comment">(1-k)</span><span class="hljs-comment">(d-c)</span>/<span class="hljs-comment">(x+2l)</span><br></code></pre></td></tr></table></figure><p>这样，就可以把连续集合的拆分开了。</p><hr><h3 id="按键事件的利用"><a href="#按键事件的利用" class="headerlink" title="按键事件的利用"></a>按键事件的利用</h3><p>这个有趣的功能，如果不看源码，估计是猜不出来。尝试按着alt键，再选择下拉框的项，看看是不是变成慢动作了？这个功能对于观察对象连贯性非常有用。这里利用了javascript的按键事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;window&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-title function_">funciton</span>()(altKey = d3.<span class="hljs-property">event</span>.<span class="hljs-property">altKey</span>));<br></code></pre></td></tr></table></figure><p>这句保证了两个事实：</p><ol><li>保证按住键了</li><li>保证按住的键为alt键</li></ol><p>只有两者都实现了，才能使得返回的结果为true。</p><hr><p>更多注解请下载本文引用的javascript。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>D3内嵌选择器</title>
    <link href="/2015/01/21/2015-01-21-d3-nested-selections/"/>
    <url>/2015/01/21/2015-01-21-d3-nested-selections/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="http://bost.ocks.org/mike/nest/">Nested Selections</a>，感谢</p></blockquote><p>D3支持<code>d3.selectAll(&quot;A B&quot;)</code>的方式内嵌选择器，这个跟<code>d3.select(&quot;A&quot;).selectAll(&quot;td&quot;)</code>的效果一致。</p><!-- excerpt --><hr><h3 id="嵌套与索引"><a href="#嵌套与索引" class="headerlink" title="嵌套与索引"></a>嵌套与索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;tbody td&quot;</span>);<br></code></pre></td></tr></table></figure><p>出来的结果是垂直结构的，td元素会自动产生递增索引。如出来的结果有16个，那么索引由0递增至15。</p><p>D3的嵌套选择器保留垂直结构的特点。如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;tbody tr&quot;</span>).<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;td&quot;</span>);<br></code></pre></td></tr></table></figure><p>即使结构中多出了分组用的母节点tr，也不会影响td元素的垂直结构，td的索引还是由0递归至15。</p><hr><h3 id="嵌套与数据"><a href="#嵌套与数据" class="headerlink" title="嵌套与数据"></a>嵌套与数据</h3><p>如果嵌套选择器需要绑定一个二维数组，需要先让选择器上层绑定数组外围，在对选择器的单元绑定数据内部。如matrix为数据二维数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> matrix = [<br>  [ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>  [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>  [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],<br>  [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>];<br></code></pre></td></tr></table></figure><p>第一重绑定为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tr = d3.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;tbody tr&quot;</span>).<span class="hljs-title function_">data</span>(matrix);<br></code></pre></td></tr></table></figure><p>，第二重绑定为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">tr.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;td&quot;</span>).<span class="hljs-title function_">data</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>)&#123;<span class="hljs-keyword">return</span> d;&#125;);<br></code></pre></td></tr></table></figure><p>。注意不能直接使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;tbody tr td&quot;</span>).<span class="hljs-title function_">data</span>(matrix);<br></code></pre></td></tr></table></figure><p>，那是因为matrix的值个数为16，但是第一次绑定时，d3认为那是含有四个数组的数组而已，职能绑定选择器的前4项。</p><hr><h3 id="嵌套与母节点"><a href="#嵌套与母节点" class="headerlink" title="嵌套与母节点"></a>嵌套与母节点</h3><p>使用嵌套选择器存在一个隐藏的特性：对每个元素分组都会设定一个母节点。增加节点的操作是会针对这个母节点下添加。如果在一开始就使用嵌套选择器，如（matrix数组的个数要比原始tr元素多才有效果）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;tbody tr&quot;</span>).<span class="hljs-title function_">data</span>(matrix).<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br></code></pre></td></tr></table></figure><p>，这个结果会报一个错：节点无法添加tr元素。原因其实是开始使用的嵌套选择器会默认把网页的根几点html作为默认的选择器母节点，而html节点下是不能添加tr元素的。这个时候可以选择放弃嵌套：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;tbody&quot;</span>).<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;tr&quot;</span>).<span class="hljs-title function_">data</span>(matrix).<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br></code></pre></td></tr></table></figure><p>，让母节点设置为tbody。</p><hr><h3 id="是否需要内嵌"><a href="#是否需要内嵌" class="headerlink" title="是否需要内嵌"></a>是否需要内嵌</h3><p>这里提到，在select和selectAll之间存在一个重要的区别：select方法会<em>保留</em>存在的分组，而selectAll会<em>新建</em>一个分组。使用select方法会保留数据、索引、原选择器的母节点。</p><p>推荐使用方式是，先有一个确定的选择器，再在这个选择器的基础上使用selectAll，这样selectAll的分组中，都是以这个确定的选择器作为母节点进行下一步的操作。这也是data方法都是紧跟这selectAll的原因——不用担心使用未知的母节点。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>D3选择器原理及数据绑定练习</title>
    <link href="/2015/01/09/2015-01-09-d3-binding-data-ex/"/>
    <url>/2015/01/09/2015-01-09-d3-binding-data-ex/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="http://bost.ocks.org/mike/selection/">How Selections Work</a>，感谢</p></blockquote><h3 id="元素分组"><a href="#元素分组" class="headerlink" title="元素分组"></a>元素分组</h3><p>选择器是一个分组（groups）数组，每个分组是元素（elements）数组。</p><p>使用selectAll方法，会使旧选择器变成新选择器中的一个分组。此分组中会多出一个母节点属性，会存储组中元素的母元素信息。</p><p>大多数使用，可以通过内置api自动遍历分组内每个元素。函数的第二参数可以指定处理某个索引的元素。</p><hr><h3 id="非分组操作"><a href="#非分组操作" class="headerlink" title="非分组操作"></a>非分组操作</h3><p>只有selectAll有针对分组的特定行为。select操作会保留现有的分组。</p><p>select与selectAll不同之处，在于对旧选择器中每个元素，在新选择器中必须拥有一个元素。而且数据也会由母节点传递到子节点。</p><p>append和insert方法是select的顶层封装，所以他们也会保留分组和传递数据</p><!-- excerpt --><hr><h3 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h3><p>分组可以通过null代替没有选择到的空元素。空元素通常会被大部分操作忽略，如改变元素样式和属性的操作会屏蔽空元素。</p><p>虽然操作会忽略空元素，但是空元素会占用分组索引，使用时要注意索引</p><hr><h3 id="绑定数据（Data）"><a href="#绑定数据（Data）" class="headerlink" title="绑定数据（Data）"></a>绑定数据（Data）</h3><p>data不是选择器的一个属性，而是选择器中元素的属性。</p><p>当我们绑定一个元素在选择器上时，实际上数据会保存在DOM上：数据会分配到每个元素的__data__属性上。当某个元素缺少__data__属性，它的datum就是undefined了。</p><p>绑定数据方式：</p><ul><li>通过selection.data，可以为选择器中的每个元素绑定数据</li><li>通过selection.detum，可以为选择的单个元素绑定数据</li><li>通过append、insert或select可继承母节点数据</li></ul><hr><h3 id="什么是数据？（Data）"><a href="#什么是数据？（Data）" class="headerlink" title="什么是数据？（Data）"></a>什么是数据？（Data）</h3><p>D3中的数据指值数组。值可以是数值，可以是对象（如JSON对象），也可以是数组。</p><p>selection.data可以接收一个常量，也可以接收一个方法。但是selection.data是针对每个组定义数据而不是针对单个元素。selection.data表示为一个常量数组或方法要返回一个数组支持把数据分发到选择器的每一个元素上。也就是说一个分组的选择器，拥有相应的分组数据。</p><p>设计数据方法时，传入分组的母节点（d参数）和元素在分组的索引（i参数），返回一个值数组用于加入到分组中。</p><hr><h3 id="键引导"><a href="#键引导" class="headerlink" title="键引导"></a>键引导</h3><p>首先确认哪个元素需要绑定哪个数据。实现这个的方式是通过配对的键。当元素的键与数据的键一致时，对应的数据就会绑定到对应的元素上。最简单的方式是通过索引。</p><p>其次可以自定义键方法。定义一个返回键的方法，并设为selection.data的第二参数。方法会在每个元素运行，也会在数据数组中运行。相同的键会绑定。</p><hr><h3 id="Enter、Update和Exit"><a href="#Enter、Update和Exit" class="headerlink" title="Enter、Update和Exit"></a>Enter、Update和Exit</h3><p>当通过键为元素绑定一个数据时，D3会得到以下三种结果：</p><ul><li>update：对于给定的数据集键，找到元素键匹配。</li><li>enter：对于给定的数据集键，找不到元素键匹配。</li><li>exit：对于给定的元素键，找不到数据集键匹配。</li></ul><p>selection.data会执行update处理，update的结果会绑定到元素上，匹配不上补为null；selection会执行enter处理，通过selection.enter可以获得匹配不上的数据集；selection会执行exit处理，通过selection.exit可以获得匹配不上的元素集。</p><p>经过update或exit处理后的数据是一个普通的选择器，但enter处理后是一个选择器的子类。这是因为enter处理的结果元素还不算真实存在。一个enter选择器包含的是简单的只包含data属性的简单对象，而不是DOM对象。引用enter.select，才能专门把这些节点作为一个元素塞进分组母节点中。所以在进行数据绑定前，一定要通过selectAll方法进行转换，确保不是单纯的简单对象。</p><hr><h3 id="按默认的索引进行数据绑定"><a href="#按默认的索引进行数据绑定" class="headerlink" title="按默认的索引进行数据绑定"></a>按默认的索引进行数据绑定</h3><p>例子根据索引进行绑定的原理。</p><link rel="stylesheet" href="/assets/css/d3_data_binding/default.css"><link href="/assets/css/metro.min.css" rel="stylesheet"><link rel="stylesheet" href="/assets/css/default.css"><link href="/assets/css/petty_colors.css" rel="stylesheet"><p><example1></example1></p><ol><li>初次化都是新增。</li><li>如果再次执行时，新随机的个数比之前的少，之前多出的部分会通过exit退出，其他会被替换为新随机的值。棕色是被退出的值。</li><li>如果再次执行时，新随机的个数比之前的多，之前的值直接被全覆盖。而绿色为多出来的位数。</li></ol><p>这种绑定方式是不会根据值更新的。即使是相同的值，但在不同的索引上，一样会被直接覆盖。</p><h3 id="引入自定义key进行数据绑定"><a href="#引入自定义key进行数据绑定" class="headerlink" title="引入自定义key进行数据绑定"></a>引入自定义key进行数据绑定</h3><p>例子采用了名字为key的绑定原理。</p><p><example2></example2></p><p>在绑定时使用了</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">.<span class="hljs-title function_">data</span>(data, <span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>) &#123;<span class="hljs-keyword">return</span> d&#125;)<br></code></pre></td></tr></table></figure><p>这句会在选择器的每个元素都跑一次，也会在data数组中每个索引跑一次。两者产生的结果相同的话，就会绑定在一起。</p><ol><li>如果上次存在的字母，新的也存在，则变为黑色。</li><li>如果上次不存在的字母，新的存在，则新增为绿色。</li><li>如果上次存在的字母，新的不存在，则置为棕色并退出。</li></ol><p>这种方式看起来会更加符合更新逻辑。</p><p><example3></example3></p><script type="text/javascript" src="/assets/js/d3_data_binding/share.js"></script><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OMPTestingHelper介绍</title>
    <link href="/2014/09/30/2014-09-30-OMPTestingHelper/"/>
    <url>/2014/09/30/2014-09-30-OMPTestingHelper/</url>
    
    <content type="html"><![CDATA[<h4 id="入口（index-js）"><a href="#入口（index-js）" class="headerlink" title="入口（index.js）"></a><strong>入口（index.js）</strong></h4><p>包含服务、路由初始化，路由映射等</p><hr><h4 id="http服务（server-js）"><a href="#http服务（server-js）" class="headerlink" title="http服务（server.js）"></a><strong>http服务（server.js）</strong></h4><p>建立http服务，按照路由映射发送请求</p><hr><h4 id="路由（route-js）"><a href="#路由（route-js）" class="headerlink" title="路由（route.js）"></a><strong>路由（route.js）</strong></h4><p>按照请求内容分配</p><!-- excerpt --><hr><h4 id="请求处理（requestHandlers-js）"><a href="#请求处理（requestHandlers-js）" class="headerlink" title="请求处理（requestHandlers.js）"></a><strong>请求处理（requestHandlers.js）</strong></h4><p>实现查询逻辑</p><ul><li><code>show*</code>：<code>show*</code>的作用是建立请求的页面，包含请求使用的form元素，加上外部的ajax调用，实现工具数据输入</li><li><code>query*</code>或<code>get*</code>：<code>query*</code>或<code>get*</code>的作用是对查询服务器进行请求并接收返回值。调用<code>query*</code>或<code>get*</code>的方法只能通过<code>show*</code>中ajax调用</li><li><code>static</code>：静态文件下载请求使用</li></ul><hr><h4 id="生成器（generator-js）"><a href="#生成器（generator-js）" class="headerlink" title="生成器（generator.js）"></a><strong>生成器（generator.js）</strong></h4><p>生成器与之后描述的过滤器均属于解析、可视化服务器返回Json的方法。</p><ul><li><code>txt_gen</code>：生成txt文件用。实际使用可以提供自动化测试结果下载</li><li><code>html_gen</code>：生成html展示用。</li></ul><p>提供四种最外层数据结构的Json进行解析，其余情况不解释</p><ul><li>list：需要解析的内容是列表形式</li><li>single：最普通的结构</li><li>map：需要解析的内容如{1:{key1:value1},2:{key2:value2}}</li><li>nofield：无字段形式，内容只有一个值的情况</li></ul><hr><h4 id="过滤器（filter-js）"><a href="#过滤器（filter-js）" class="headerlink" title="过滤器（filter.js）"></a><strong>过滤器（filter.js）</strong></h4><p>过滤器用于增强生成器的解析能力，通过生成器与过滤器递归调用使用。</p><ul><li><code>datetime</code>：日期时间，把时间格式化为”YYYY-MM-DD HH:mm:ss”</li><li><code>date</code>：日期，把时间格式化为”YYYY-MM-DD”</li><li><code>txt_*</code>：把对应格式转换为规定的文本格式</li><li><code>html_*</code>：把对应格式转换为规定的html格式</li><li><code>str_list</code>：对字符串列表进行加工</li><li><code>time_list</code>：对时间列表进行加工</li><li><code>html_warp</code>：对过长的字符串列表按逗号进行截取，分行显示</li></ul><hr><h4 id="配置文件（config-x2F-default-json）"><a href="#配置文件（config-x2F-default-json）" class="headerlink" title="配置文件（config&#x2F;default.json）"></a><strong>配置文件（config&#x2F;default.json）</strong></h4><p>default.json记录了工具展示数据的结构，可以实现增量扩展。</p><p>这个文件分为三部分，static、store和routeinterface。</p><p>static部分是用于请求处理里<code>static</code>方法的配置，后缀与接收格式的关系。</p><p>store部分是提供展示的结构，用于解析和展示返回的Json。此配置的格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;store&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;store_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;cn_name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;中文名称&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;分组名称&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;txt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;字段1显示名&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;字段1过滤&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;child_field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;child_field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;子字段1显示名&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;child_filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;child_filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;子字段1过滤&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;dir&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;生成文件存放位置&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;txt生产器数据类型&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;需要转换的内容段&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;content_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;html生产器数据类型&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;html&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;字段1显示名&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;字段1过滤&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;child_field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;child_field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;子字段1显示名&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;child_filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;child_filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;子字段1过滤&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>配置说明：</p><ul><li>如果不需要生产txt，<code>&quot;txt&quot;</code>可以不用配置；</li><li><code>&quot;txt&quot;</code>是一个列表，可以接受多个文件生成，以满足多种结构的数据验证</li><li><code>&quot;filter&quot;</code>、<code>&quot;child_field&quot;</code>、<code>&quot;child_filter&quot;</code>均是可选填</li><li><code>&quot;content&quot;</code>选填，用于解析子一级Json；默认不配置就是解析整个Json对象</li><li><code>&quot;content_type&quot;</code>字段描述的是，用于产生html的解析结构</li><li><code>&quot;txt&quot;</code>的<code>&quot;type&quot;</code>字段描述的是，用于产生txt文件的解析结构。为什么要独立于<code>&quot;content_type&quot;</code>设定txt的解析结构？原因有二：<code>&quot;content&quot;</code>可以自定义局部使用整个Json对象的子级（如<code>&quot;parent&quot;:&#123;&quot;child_1&quot;:&#123;&#125;,&quot;child_2&quot;:&#123;&#125;&#125;</code>，可以配置<code>&quot;content&quot;</code>的值为<code>&quot;child_1&quot;</code>，这样就可以局部解析<code>&quot;child_1&quot;</code>），而子级一般对母级结构不一样；<code>&quot;txt&quot;</code>是一个独立的生成应用，需要各自设定</li></ul><p>routeinterface部分提供内部静态路由接口查询功能。基本配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;routeinterface&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;interfaceName2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;接口名称&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;分组名称&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;arg_1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;参数名1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;参数录入类型&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;arg_1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;参数名1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;参数录入类型&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;content_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;list&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;html&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;字段1显示名&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;字段1过滤&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;child_field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;child_field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;子字段1显示名&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;child_filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;child_filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;子字段1过滤&quot;</span><span class="hljs-punctuation">,</span><br>……<br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>配置说明：</p><ul><li>routeinterface需要严格配置，也需要服务端的支持</li><li><code>&quot;name&quot;</code>字段严格按照接口方法去掉get或find后剩下的部分，加上参数个数合成（参数个数超过10则用9），如getBatch有两个参数，则名称为Batch2</li><li><code>&quot;args&quot;</code>字段负责查询参数form格式配置，其中<code>&quot;type&quot;</code>有3种类型：<br>*    <code>&quot;text&quot;</code>：字符串格式<br>*    <code>&quot;datetime&quot;</code>：日期时间格式<br>*    <code>&quot;select&quot;</code>：下拉选项，需要配置<code>&quot;option&quot;</code></li><li>其他html生成参考store配置说明</li></ul><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NODEJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Three Little Circles教程缺陷</title>
    <link href="/2014/08/21/2014-08-21-three-little-circles-tutorial-bug/"/>
    <url>/2014/08/21/2014-08-21-three-little-circles-tutorial-bug/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔者最近对开源数据图形化库d3产生兴趣，开始学习相关教程。<br>教程来自<a href="http://bost.ocks.org/mike/circles/">Three Little Circles</a>，感谢</p></blockquote><p>就原因来说，可能是由于<a href="https://github.com/mbostock/d3">新版本的d3</a>与<a href="http://bost.ocks.org/mike/circles">教程</a>不同步导致的。首先我们来看结果，按照教程出来的结果是：</p><p><svg id="test" width="720" height="120"><circle cx="40" cy="60" r="10"></circle><circle cx="80" cy="60" r="10"></circle><circle cx="120" cy="60" r="10"></circle><circle cy="60" cx="330" r="17.11724276862369"></circle></svg></p><p>而我们教程的目标却是：</p><p><svg id="test" width="720" height="120"><circle cx="30" cy="60" r="5.656854249492381"></circle><circle cx="130" cy="60" r="7.54983443527075"></circle><circle cx="230" cy="60" r="10.583005244258363"></circle><circle cy="60" cx="330" r="15.459624833740307"></circle></svg></p><p>很明显，前三个圆出问题了。原因是教程中的<a href="http://bost.ocks.org/mike/circles/#entering">circleEnter</a>对象并没有包含原始的三个circle。我在这并不分析为什么没有包含，想借此介绍发现问题的经验。</p><!-- excerpt --><p>开始时笔者并没有使用任何debug的工具，笨笨地使用console.log打印对象，验证问题。开发工具是Sublime Text 2，就这样一行一行的敲。刚开始发现问题的时候，我通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(circleEnter);<br></code></pre></td></tr></table></figure><p>打印出circleEnter对象后发现对象内有个数组前3个为null，想必问题出在这，导致后续的回调函数无法应用到前三个圆上。</p><p>但是知识浅薄的笔者并没有发现问题的关键，进而把问题认定为<em>d3不兼容nodejs</em>。接下来为了验证这点，笔者直接在主页把这段javascript写上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;http://d3js.org/d3.v3.min.js&quot;</span> charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;&lt;/script&gt;<br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> svg = d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;svg&quot;</span>);<br>    <span class="hljs-keyword">var</span> circle = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;circle&quot;</span>)<br>        .<span class="hljs-title function_">data</span>([<span class="hljs-number">32</span>, <span class="hljs-number">57</span>, <span class="hljs-number">112</span>, <span class="hljs-number">293</span>]);<br>    <span class="hljs-keyword">var</span> circleEnter = circle.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;circle&quot;</span>);<br>    circleEnter.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">60</span>);<br>    circleEnter.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;cx&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">d, i</span>) &#123; <span class="hljs-keyword">return</span> i * <span class="hljs-number">100</span> + <span class="hljs-number">30</span>; &#125;);<br>    circleEnter.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(d); &#125;);<br>&lt;script&gt;<br></code></pre></td></tr></table></figure><p>结果并不如笔者所愿，还是错误的结果，那么认定被攻破。下一个当然就是怀疑这个代码有问题了。</p><p>自以为是的笔者打算看看源代码，可惜d3的作者比笔者强太多了，笔者很快就放弃了。终于想到求助debug工具（回想起来都觉得笨死了）。</p><p>很快在谷歌上找到各种工具，我想优先试试Sublime Text 2上的插件NodejsDebug。两个字：难用。使用快捷键后就保存了一下文档就没反应了。不过在介绍NodejsDebug的教程上都提到了需要预安装nodejs的扩展包<a href="https://github.com/node-inspector/node-inspector">node-inspector</a>。</p><p>根据Github的使用介绍，发现那个NodejsDebug完全就是在Sublime Text 2上加个键，接着就是node-inspector的事了。要运行node-inspector进行nodejs脚本调试，依照以下步骤：</p><ol><li>把Chrome设成默认浏览器</li><li>保存nodejs脚本<code>&lt;script.js&gt;</code></li><li>打开shell（或cmd），到脚本目录</li><li>执行<code>node-debug &lt;script.js&gt;</code></li></ol><p>就这样，nodejs会启动一个debug服务器，并使用Chrome开发工具进行断点、对象查看等debug功能。</p><p>使用以上功能，笔者很快就定位到问题所在。当执行完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> circleEnter = ircle.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;circle&quot;</span>);<br></code></pre></td></tr></table></figure><p>发现circleEnter对象如开始时描述一样，有个数据的前三个为null；而circle对象则在原来基础上增加了第四个圆，且前三个都保留着。从而，教程是有问题的，正确的代码应该是：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://d3js.org/d3.v3.min.js&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> svg = d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;svg&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> circle = svg.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&quot;circle&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        .<span class="hljs-title function_">data</span>([<span class="hljs-number">32</span>, <span class="hljs-number">57</span>, <span class="hljs-number">112</span>, <span class="hljs-number">293</span>]);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> circleEnter = circle.<span class="hljs-title function_">enter</span>().<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;circle&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    circle.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;cy&quot;</span>, <span class="hljs-number">60</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    circle.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;cx&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">d, i</span>) </span></span><span class="language-xquery">&#123; <span class="hljs-keyword">return</span> i * <span class="hljs-number">100</span> + <span class="hljs-number">30</span>; &#125;</span><span class="language-xml"><span class="language-javascript">);</span></span><br><span class="language-javascript"><span class="language-xml">    circle.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>) </span></span><span class="language-xquery">&#123; <span class="hljs-keyword">return</span> Math.sqrt(d); &#125;</span><span class="language-xml">);</span><br><span class="language-xml"></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span></span></span><br></code></pre></td></tr></table></figure><p>详细代码：<a href="https://github.com/ghold/D3Study/blob/master/lessons/2/requestHandlers.js">github.com&#x2F;ghold</a></p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3 NODEJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在nodejs上用d3</title>
    <link href="/2014/08/19/2014-08-19-use-d3-on-nodejs/"/>
    <url>/2014/08/19/2014-08-19-use-d3-on-nodejs/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔者最近对开源数据图形化库d3产生兴趣，开始学习相关教程。</p></blockquote><p>nodejs拥有异步I&#x2F;O、事件驱动等优点。不过笔者对以上两个特点理解得不太深入，喜欢使用的原因是看到可以把javascript搬到后台去，而且使用的是谷歌V8，如此高大上怎么应该试一下。</p><p>今天的话题是如何把d3搬到nodejs上，进而把牛X的数据图形化库应用在后台，动态生成静态页面。其实呢，nodejs与javascript的库兼容性都是很好的。基本思想是，在node内部模拟一个dom对象，d3对这个dom对象处理完后必会对这个dom对象做出修改，最后node输出这个静态dom对象到浏览器即可。</p><!-- excerpt --><p>预置的配置是nodejs与一个简单的server框架，建议参考：<a href="http://www.nodebeginner.org/index-zh-cn.html">node入门</a>，很详细地教大家如何建立一个简单的扩展性强的server。</p><p>接下来是安装d3，有npm的帮助，也是很容易：</p><figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">npm</span> install <span class="hljs-built_in">d3</span><br></code></pre></td></tr></table></figure><p>由于是编译安装，所以安装过程中可能会有各种问题，如找不到python、编译C用的编译器找不到等等。（笔者屌丝，买不起mac，所以只能在Windows下开发）建议</p><ol><li><p>安装<a href="https://www.python.org/downloads/">python 2.7</a>并配置PYTHON_HOME为python安装目录；</p></li><li><p>安装<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=34673">Microsoft Visual Studio 2012 Express</a>并在命令行执行：</p> <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">npm config <span class="hljs-keyword">set</span> msvs_<span class="hljs-keyword">version</span> 2012 <span class="hljs-params">--global</span><br></code></pre></td></tr></table></figure></li></ol><p>在安装过程中，我们可以发现d3需要依赖一个名为jsdom的库。这个就是我们在node内部模拟dom对象的关键库。jsdom可以把html文本转换为dom对象，使得d3可以在node内部随意使用自己的api处理这个dom对象。jsdom的用法也很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsdom = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsdom&#x27;</span>)<br><span class="hljs-keyword">var</span> index = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./lessons/1/template/index.html&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>jsdom.<span class="hljs-title function_">env</span>(&#123;<br>    features : &#123; <span class="hljs-title class_">QuerySelector</span> : <span class="hljs-literal">true</span> &#125;<br>, html : index<br>, done : <span class="hljs-keyword">function</span>(<span class="hljs-params">errors, <span class="hljs-variable language_">window</span></span>) &#123;<br>    <span class="hljs-keyword">var</span> body = <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;body&#x27;</span>);<br><span class="hljs-comment">//to do</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>接着就可以使用d3随意处理body对象，处理完毕后通过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> svgsrc = <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-property">innerHTML</span>;<br></code></pre></td></tr></table></figure><p>取出处理结果，利用server框架输出到浏览器即可。</p><p>详细代码：<a href="https://github.com/ghold/D3Study/blob/master/lessons/1/requestHandlers.js">github.com&#x2F;ghold</a></p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>D3 NODEJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Storm学习笔记（一）</title>
    <link href="/2014/02/19/2014-02-19-study-storm-1/"/>
    <url>/2014/02/19/2014-02-19-study-storm-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>感谢<a href="http://xumingming.sinaapp.com/">xumingming</a>提供的中文翻译<a href="http://xumingming.sinaapp.com/117/twitter-storm%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/">《Twitter Storm的一些关键概念》</a><br>感谢官方wiki提供的<a href="https://github.com/nathanmarz/storm/wiki/Concepts">原文</a></p></blockquote><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="计算拓扑：Topologies"><a href="#计算拓扑：Topologies" class="headerlink" title="计算拓扑：Topologies"></a>计算拓扑：Topologies</h4><ol><li>Topology对象里包含实时计算程序</li><li>一个Storm的Topology会一直运行——除非显式杀死</li><li>一个Topology是Spouts和Bolts组成的图状结构，而连接Spouts和Bolts的则是Stream groupings</li></ol><h5 id="参考阅读："><a href="#参考阅读：" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="http://nathanmarz.github.io/storm/doc/index.html">TopologyBuilder</a>：使用这个类在Java中构造计算拓扑</li><li><a href="https://github.com/nathanmarz/storm/wiki/Running-topologies-on-a-production-cluster">在生产集群上运行计算拓扑</a></li><li><a href="https://github.com/nathanmarz/storm/wiki/Local-mode">本地模式</a>：通过这篇文章学习如何在本地模式开发和测试计算拓扑</li></ol><!-- excerpt --><h4 id="信息流：Streams"><a href="#信息流：Streams" class="headerlink" title="信息流：Streams"></a>信息流：Streams</h4><ol><li>一个信息流是一个没有边界的tuple（数据元组）序列，而这些tuples会被以一种分布式的方式并行地创建和处理</li></ol><ul><li>信息流是一个tuple序列</li><li>没有边界是什么意思？</li><li>分布式并行创建和处理。创建后用于分发到不同的Bolts进行处理？</li></ul><ol start="2"><li>在序列中的tuple有一致的结构，即不同tuple相同位置字段类型一样</li><li>由于大多信息流都是单向的，每个Stream会带有一个id，作为唯一标识</li></ol><h5 id="参考阅读：-1"><a href="#参考阅读：-1" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/tuple/Tuple.html">Tuple（元组）</a>：信息流由元组组成</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/topology/OutputFieldsDeclarer.html">OutputFieldsDeclarer</a>：用于定义信息流和信息流的结构</li><li><a href="https://github.com/nathanmarz/storm/wiki/Serialization">Serialization（序列化器）</a>：关于Storm的元组动态类型和声明自定义序列化</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/serialization/ISerialization.html">ISerialization</a>：自定义的序列化器都要使用这个接口</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/Config.html#TOPOLOGY_SERIALIZATIONS">CONFIG.TOPOLOGY_SERIALIZATIONS</a>：自定义序列化器可以通过这个配置注册</li></ol><h4 id="信息源：Spouts"><a href="#信息源：Spouts" class="headerlink" title="信息源：Spouts"></a>信息源：Spouts</h4><ol><li>Spouts在计算拓扑中扮演生产者的角色。一般来说，Spouts会从一个外部源读取数据生成数据元组，并把数据元组发射进计算拓扑中</li><li>Spouts可以是可靠的也可以是不可靠的。</li></ol><ul><li>可靠的信息源：如果Storm没有成功处理数据元组，信息源会重新发射一遍元组</li><li>不可靠的信息源：一旦信息源发射完数据元组，就会忘记这个动作（不管发出去的数据元组是否成功处理）</li></ul><ol start="3"><li>Spouts可以发射多条信息流。使用OutputFieldsDeclarer.declareStream定义stream，使用OutputCollector.emit来选择要发射的stream</li><li>Spouts类型中最重要的方法是nextTuple。nextTuple会做两件事：发射一个新的元组进计算拓扑或如果没有新的数据元组就简单放回（return）。要注意的是，nextTuple不能打断（block）任何Spout的实现，因为Storm会在同一个线程上调用全部Spout方法</li><li>ack和fail是另外两个重要的方法。当Storm监测到Spout发出的数据元组被计算拓扑成功处理或者处理失败时，Storm会调用ack方法或者fail方法。Storm只为可靠的信息源调用ack和fail。</li></ol><h5 id="参考阅读：-2"><a href="#参考阅读：-2" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/topology/IRichSpout.html">IRichSpout</a>：信息源必须实现的接口</li><li><a href="https://github.com/nathanmarz/storm/wiki/Guaranteeing-message-processing">如何保证信息不丢失</a></li></ol><h4 id="信息处理者：Bolts"><a href="#信息处理者：Bolts" class="headerlink" title="信息处理者：Bolts"></a>信息处理者：Bolts</h4><ol><li>所有计算拓扑里的计算过程都封装在bolts中。Blots中可以实现所有过程，如过滤、函数、聚合、接合、与数据库联动等等</li><li>Blots可以做简单的数据流传递。做复杂的信息流传递通常需要多个步骤，因此也需要多个Bolts。</li><li>同样，Bolts也有可以发射多条信息流的特性。</li><li>当声明一个Bolt的输入流时，需要订阅其他组件的特定数据流。如果想要订阅其他组件的全部数据流，你必须逐个订阅每个数据流。Storm中的InputDeclarer提供了方便的语法，用于订阅默认id声明的数据流，<code>declarer.shuffleGrouping(&quot;1&quot;)</code>可以订阅组件<code>&quot;1&quot;</code>的默认数据流</li><li>Bolts中主要方法是execute，参数是一个数据元组tuple。Bolts使用一个OutputCollector对象发射处理后的数据元组tuple。为了让Storm知道什么时候接收到的数据元组（作为execute参数的）被处理完成，Bolts必须为每个收到的数据元组tuple调用OutputCollector对象的ack方法。这样这个tuple的信息源才会知道成功处理。</li><li>一般流程：Blots处理一个输入的数据元组tuple（输入），处理结束后发射0个或多个tuple（结果），然后调用ack方法通知Storm已经处理过这个tuple（输入）了</li></ol><h5 id="参考阅读：-3"><a href="#参考阅读：-3" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/topology/IRichBolt.html">IRichBolt</a>：Bolts需要实现的接口</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/topology/IBasicBolt.html">IBasicBolt</a>：这个方便的接口可以定义过滤操作或简单的功能</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/task/OutputCollector.html">OutputCollector</a>：Bolts要发射数据元组到它们的输出信息流，用到这个类的一个实例</li><li><a href="https://github.com/nathanmarz/storm/wiki/Guaranteeing-message-processing">如何保证信息不丢失</a></li></ol><h4 id="信息分发策略：Stream-groupings"><a href="#信息分发策略：Stream-groupings" class="headerlink" title="信息分发策略：Stream groupings"></a>信息分发策略：Stream groupings</h4><ol><li>定义每个Blot应该接收怎样的输入流，是定义一个计算拓扑的一部分。一个信息分发策略定义了如何分配信息流到Blot的多个任务中</li><li>Storm中有7个内建的信息分发策略：</li></ol><ul><li>随机分组Shuffle Grouping：随机分发stream里面的tuple到bolt的任务中，保证每个bolt拿到相同数量的数据元组tuple</li><li>按字段分组Fields Grouping：信息流通过特定字段进行分组。譬如数据流以<code>user-id</code>字段分成几组，数据流中带有相同<code>user-id</code>值的数据元组tuple<strong>都会</strong>去到Bolt中相同的任务，带有不同<code>user-id</code>值的两个数据元组tuple<strong>可能会</strong>被分配到不同的任务</li><li>广播分发All Grouping：对于每一个数据元组，会分发到所有Bolt的所有任务。谨慎使用</li><li>全局分发Global Grouping：整个数据流被分发到Bolt中的单个任务，这个任务是id最小的任务</li><li>无分组None Grouping：这种分组方式是指信息流steam不关心谁会拿到它的信息元组。现时，无分组方式等价于随机分组方式。不同的地方在于，Storm会把这个bolt的执行，放到接收这个blot发射数据的信息源Spout或信息处理器Blot所在线程上。</li><li>直行分组Direct Grouping：这是一种特殊的分组方式。使用这种方式进行分组的信息流，意味着数据元组tuple的生产者可以决定消费者的某个任务能接收到这个数据元组。只有被声明为Direct Stream的信息流可以声明这种分组方法，而且只能使用emitDirect方法发射。</li><li>本地或随机分组Local or Shuffle Grouping：如果目标信息处理器Blot在同一个工作进程中有一个或多个任务，数据元组tuples会随机分发到这些进程内的任务中。否则，跟普通的随机分组一样</li></ul><h5 id="参考阅读：-4"><a href="#参考阅读：-4" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/topology/TopologyBuilder.html">TopologyBuilder</a>：使用这个类定义计算拓扑</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/topology/InputDeclarer.html">InputDeclarer</a>：当TopologyBuilder中调用setBolt方法，InputDeclarer会被返回，而且返回的InputDeclarer用于定义Bolt的信息输入流和这些流该如何分发</li><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/task/CoordinatedBolt.html">CoordinatedBolt</a>：这类处理器在分布式远程过程调用计算拓扑中很有用，而且重度使用直行信息流和直行分组</li></ol><h4 id="可靠性：Reliability"><a href="#可靠性：Reliability" class="headerlink" title="可靠性：Reliability"></a>可靠性：Reliability</h4><ol><li>Storm保证每个数据元组tuple会被topology完整执行。</li><li>Storm会追踪由每个Spout发出的tuple所产生的tuple树（一个bolt处理一个tuple之后可能会发射出别的tuple，从而可以形成树状结构），并且跟踪这棵tuple树什么时候成功处理完。</li><li>每个计算拓扑会与一个信息超时关联。如果在超时时间内Storm没有监测到由一个Spout发出的tuple已经执行成功，那么Storm会主动结束tuple运算并且随后重新进行运算</li><li>要使用Storm的可靠性特性，在发出一个新的tuple和完成处理一个tuple时必须通知Storm。Bolt使用OutputCollectior对象发射tuples，同时完成上述通知。通过它的emit方法来通知一个新的tuple产生了，通过它的ack方法通知一个tuple处理完成</li></ol><h5 id="参考阅读：-5"><a href="#参考阅读：-5" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="https://github.com/nathanmarz/storm/wiki/Guaranteeing-message-processing">如何保证信息不丢失</a></li></ol><h4 id="任务：Tasks"><a href="#任务：Tasks" class="headerlink" title="任务：Tasks"></a>任务：Tasks</h4><ol><li>在集群中，每个Spout或Bolt会作为很多任务执行</li><li>每个任务对应一个执行线程，通过信息分发策略定义怎样从一组任务中发送到另一组。</li><li>可以使用TopologyBuilder中的setSpout与setBolt方法设置任务的并行度——也就是有多少个任务</li></ol><h4 id="工作进程：Workers"><a href="#工作进程：Workers" class="headerlink" title="工作进程：Workers"></a>工作进程：Workers</h4><ol><li>一个计算拓扑可以经过一个或多个工作进程执行。每个工作进程是一个物理的Java虚拟机，执行这个计算拓扑的一部分。</li><li>比如对于任务并行度是300的计算拓扑来说，如果我们使用50个工作进程来执行，那么每个工作进程会处理其中的6个任务（其实就是每个工作进程里面分配6个线程）。Storm会尽量均匀的工作分配给所有的工作进程。</li></ol><h5 id="参考阅读：-6"><a href="#参考阅读：-6" class="headerlink" title="参考阅读："></a><em>参考阅读：</em></h5><ol><li><a href="http://nathanmarz.github.com/storm/doc/backtype/storm/Config.html#TOPOLOGY_WORKERS">Config.TOPOLOGY_WORKERS</a>：配置计算拓扑分配到的工作进程数</li></ol><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STROM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笨办法学python笔记</title>
    <link href="/2014/01/22/2014-01-22-study-python/"/>
    <url>/2014/01/22/2014-01-22-study-python/</url>
    
    <content type="html"><![CDATA[<p>一篇之前学习Python的笔记，感谢《笨办法学Python》的作者。本文是结合《笨办法学Python》和Python3.3的一些补充。</p><h4 id="Ex01"><a href="#Ex01" class="headerlink" title="Ex01"></a>Ex01</h4><ol><li><code>print</code>后要加括号（python3.3）</li></ol><h4 id="Ex02"><a href="#Ex02" class="headerlink" title="Ex02"></a>Ex02</h4><ol><li><code>#</code>号起注释作用</li></ol><h4 id="Ex03"><a href="#Ex03" class="headerlink" title="Ex03"></a>Ex03</h4><ol><li>整型运算结果一般为整型，除法结果则为浮点型</li></ol><h4 id="Ex04"><a href="#Ex04" class="headerlink" title="Ex04"></a>Ex04</h4><ol><li><code>print</code>参数连接打印时，自动插入空格</li></ol><!-- excerpt --><h4 id="Ex05"><a href="#Ex05" class="headerlink" title="Ex05"></a>Ex05</h4><ol><li><code>print</code>中多个参数格式化时，参数以元组形式传入</li></ol><h4 id="Ex06"><a href="#Ex06" class="headerlink" title="Ex06"></a>Ex06</h4><ol><li><code>%r</code>格式化方式取的是参数的原始数据，字符串参数自动增加单引号或双引号</li></ol><h4 id="Ex10"><a href="#Ex10" class="headerlink" title="Ex10"></a>Ex10</h4><ol><li><code>%r</code>用作debug，<code>%s</code>用作显示</li><li>反斜杆<code>\</code>用作转义，斜杆<code>/</code>没有意义</li><li><code>&#39;&#39;&#39;</code>（三个单引）与<code>&quot;&quot;&quot;</code>（三个双引）作用一致</li></ol><h4 id="Ex11"><a href="#Ex11" class="headerlink" title="Ex11"></a>Ex11</h4><ol><li>3.3中，<code>input()</code>已经替换掉<code>raw_input()</code></li><li>3.3中，<code>print()</code>输出不换行，需要加第二参数<code>end=&#39;&#39;</code>（双单引号）</li></ol><h4 id="Ex16"><a href="#Ex16" class="headerlink" title="Ex16"></a>Ex16</h4><ol><li>文件操作可能用到的方法：<code>open</code>，<code>read</code>，<code>truncate</code>，<code>readline</code>，<code>write(buff)</code>，<code>close</code></li><li><code>open</code>打开文件方式：</li></ol><ul><li><code>&#39;r&#39;</code>：默认打开方式，只读</li><li><code>&#39;w&#39;</code>：先清空文件，只写</li><li><code>&#39;x&#39;</code>：新建一个文件，只写。已存在文件会报错</li><li><code>&#39;a&#39;</code>：追加，在已有文件后进行写操作。只写</li><li><code>&#39;b&#39;</code>：二进制模式</li><li><code>&#39;t&#39;</code>：文本模式</li><li><code>&#39;+&#39;</code>：权限升级，拥有读和写操作。但必须至少有<code>&#39;w&#39;&#39;r&#39;&#39;x&#39;&#39;a&#39;</code>其中一项</li></ul><h4 id="Ex18"><a href="#Ex18" class="headerlink" title="Ex18"></a>Ex18</h4><ol><li>使用<code>def</code>建立函数</li><li>函数名由字母，数字和下划线<code>_</code>组成，但数字不能首位</li><li>定义或使用函数时必须带括号，定义时参数可有可无，但使用时必须按照定义时的参数进行配置。参数以逗号隔开</li><li>定义函数后要加上冒号才能进入函数体</li><li>函数体要向由缩进4个空格字符，结束函数体时要取消缩进</li><li>运行函数(<code>run</code>)、调用函数(<code>call</code>)、和 使用函数(<code>use</code>)是同一个意思</li></ol><h4 id="Ex19"><a href="#Ex19" class="headerlink" title="Ex19"></a>Ex19</h4><ol><li><code>int()</code>可以强制转换字符串为整型</li></ol><h4 id="Ex24"><a href="#Ex24" class="headerlink" title="Ex24"></a>Ex24</h4><ol><li>函数可以返回多个结果组成的元组</li></ol><h4 id="Ex25"><a href="#Ex25" class="headerlink" title="Ex25"></a>Ex25</h4><ol><li>通过<code>import</code>可以加载py后缀的文件（模块），从而通过<code>.</code>调用模块中定义的函数</li><li>在定义函数后第一行中设置<code>&quot;&quot;&quot;xxx&quot;&quot;&quot;</code>的注释，可用于<code>help()</code>查询</li></ol><h4 id="Ex27"><a href="#Ex27" class="headerlink" title="Ex27"></a>Ex27</h4><ol><li>逻辑运算符</li></ol><ul><li><code>and</code> 与</li><li><code>or</code> 或</li><li><code>not</code> 非</li><li><code>!=</code> 不等于</li><li><code>==</code> 等于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li><li><code>True</code> 真</li><li><code>False</code> 假</li></ul><h4 id="Ex30"><a href="#Ex30" class="headerlink" title="Ex30"></a>Ex30</h4><ol><li>只要一行以冒号<code>:</code>结尾，它接下来的内容就应该有缩进</li><li>4个空格的缩进表示新的代码区段创建</li></ol><h4 id="Ex32"><a href="#Ex32" class="headerlink" title="Ex32"></a>Ex32</h4><ol><li><code>range()</code>会产生一个<code>range</code>对象，可迭代。<code>range</code>函数会从第一个数到最后一个，但不包含最后一个数字。<code>range(0,5)</code>就是一个带有<code>0,1,2,3,4</code>的<code>range</code>对象</li><li>for-loop的格式是<code>for xxx in yyy:</code>其中<code>yyy</code>是可迭代对象</li><li>列表<code>list</code>有以下方法：</li></ol><ul><li><code>append</code>：追加，可理解成在最后位置插入</li><li><code>clear</code>：清空，清除所有列表内容</li><li><code>copy</code>：复制，复制一个列表副本（新的内存）</li><li><code>count</code>：数目，列表元素个数</li><li><code>extend</code>：扩展，可以从别的可迭代对象中获取元素扩展自身列表</li><li><code>index</code>：索引，列表元素索引</li><li><code>insert</code>：插入，根据 给定的位置进行插入元素</li><li><code>pop</code>：提取，会从列表中删除指定位置元素，调用时会返回该元素。没有参数时默认后进先出</li><li><code>remove</code>：移除，删除第一次出现该值的元素</li><li><code>reverse</code>：倒序，对列表进行倒序处理</li><li><code>sort</code>：排序，对序列进行排序</li></ul><h4 id="Ex33"><a href="#Ex33" class="headerlink" title="Ex33"></a>Ex33</h4><ol><li>尽量少用while-loop，大部分时候for-loop是更好的选择</li><li>重复检查你的<code>while</code>语句，确定你测试的布尔表达式最终会变成<code>False</code></li><li>while-loop的格式为<code>while xxx :</code>当满足<code>xxx</code>为<code>True</code>时开始，<code>xxx</code>为<code>False</code>时停止</li></ol><h4 id="Ex37"><a href="#Ex37" class="headerlink" title="Ex37"></a>Ex37</h4><ol><li>关键字学习</li></ol><ul><li><code>and</code>：逻辑运算符，与</li><li><code>del</code>：删除变量，包括命名和值</li><li><code>from</code>：加载模块使用，与<code>import</code>一起，从<code>xxx</code>导入<code>yyy</code></li><li><code>not</code>：逻辑运算符，非</li><li><code>while</code>：while-loop核心，<code>True</code>时运行循环体，<code>False</code>时退出循环</li><li><code>as</code>：别名，指向。如在<code>import</code>后时，用作导入模块的别名；用在<code>with</code>后时，可以指代<code>with</code>后的with_item，并在<code>with</code>内部使用</li><li><code>elif</code>：否则如果，<code>if</code>语句的带条件分支。</li><li><code>global</code>：定义全局变量</li><li><code>or</code>：逻辑运算符，或</li><li><code>with</code>：通过把<code>xxx</code>替换为<code>yyy</code>，执行下面的代码</li><li><code>assert</code>：测试用，测试表达式1，如果为<code>False</code>，抛出异常并执行表达式2</li><li><code>else</code>：否则，<code>if</code>语句的不带条件分支，后不能再接<code>if</code>的分支</li><li><code>if</code>：条件语句</li><li><code>pass</code>：空语句，跳过，保持结构完整性</li><li><code>yield</code>：量产，可以根据控制生产结果。带有<code>yield</code>的函数为生成器，每次调用到<code>yield</code>停止，再次调用会从上次结束的地方，保持上次的状态执行到<code>yield</code>关键字</li><li><code>break</code>：跳出循环</li><li><code>except</code>：与<code>try</code>一起用，捕获异常，进行异常处理</li><li><code>import</code>：加载模块，使外部模块可以调用</li><li><code>class</code>：类，定义类</li><li><code>in</code>：如果<code>xxx</code>在<code>yyy</code>中，则<code>xxx in yyy</code>返回<code>True</code>。可以与<code>for</code>一起做for-loop</li><li><code>raise</code>：强制抛出一个异常</li><li><code>continue</code>：跳出本次循环并进行下一次循环</li><li><code>finally</code>：在<code>try</code>块后引用，无论是否出现异常，总会执行<code>finally</code>块</li><li><code>is</code>：判断两者是否为同一对象，类型相同且值相同时返回<code>True</code>，否则返回<code>False</code></li><li><code>return</code>：返回，在函数中返回值</li><li><code>def</code>：定义函数</li><li><code>for</code>：for-loop使用，与<code>in</code>一起</li><li><code>lambda</code>：匿名函数</li><li><code>try</code>：用于异常处理，放在函数执行前，配合<code>except</code>从句和<code>finally</code>块使用</li><li><code>nonlocal</code>：用于闭包内修改外部变量。如果不定义<code>nonlocal</code>，闭包内只能读外部变量，而不能修改（非全局变量）</li><li><code>None</code>：常量，空值，数据类型为<code>NoneType</code>，与非<code>None</code>值比较总返回<code>False</code></li><li><code>True</code>：布尔值，真</li><li><code>False</code>：布尔值，假</li></ul><ol start="2"><li>字符串格式化 <code>print(&quot;The format is %* &quot; % arg)</code> *替换以下格式</li></ol><ul><li><code>%d</code>，<code>%i</code>：带符号的十进制整数</li><li><code>%o</code>：不带符号的八进制</li><li><code>%u</code>：不带符号的十进制</li><li><code>%x</code>：不带符号的十六进制（小写）</li><li><code>%X</code>：不带符号的十六进制（大写）</li><li><code>%e</code>：科学计数法的浮点数（小写）</li><li><code>%E</code>：科学计数法的浮点数（大写）</li><li><code>%f</code>，<code>%F</code>：十进制浮点数</li><li><code>%g</code>：如果指数大于-4或者小于精度值则和e相同，否则和f相同</li><li><code>%G</code>：如果指数大于-4或者小于精度值则和E相同，否则和F相同</li><li><code>%c</code>：单字符（接受整数或者单字符字符串）</li><li><code>%r</code>：字符串（使用<code>repr</code>转换任意Python对象）</li><li><code>%s</code>：字符串（使用<code>str</code>转换任意Python对象）</li></ul><ol start="3"><li>操作符号</li></ol><ul><li><code>+</code>：加法，正则中可匹配1个或多个字符</li><li><code>-</code>：减法，负号，正则中可连接一个字符范围</li><li><code>*</code>：乘法，正则中可匹配0个或多个字符；收集其余的位置参数</li><li><code>**</code>：幂运算；收集关键字参数</li><li><code>/</code>：除法</li><li><code>//</code>：除法，结果向下取整</li><li><code>%</code>：取余</li><li><code>&lt;</code>：小于</li><li><code>&gt;</code>：大于</li><li><code>&lt;=</code>：小于等于</li><li><code>&gt;=</code>：大于等于</li><li><code>==</code>：等于，相等返回<code>True</code></li><li><code>!=</code>：不等于</li><li><code>()</code>：运算中的优先计算；函数定义或调用时包含参数；正则中用于分组；定义元组</li><li><code>[]</code>：定义列表；序列中放置索引；正则中的范围单字符</li><li><code>&#123;&#125;</code>：定义字典；正则中用于指定重复次数</li><li><code>@</code>：修饰符，包装函数（需要深入一下）</li><li><code>,</code>：分隔参数</li><li><code>:</code>：开始新的代码块；索引集省略中间索引；键值对分隔</li><li><code>.</code>：子模块，对象属性</li><li><code>=</code>：赋值</li><li><code>;</code>：表达式结束</li><li><code>+=</code>：加值符</li><li><code>-=</code>：减值符</li><li><code>*=</code>：乘值符</li><li><code>/=</code>：除值符</li><li><code>//=</code>：除值符，结果向下取整</li><li><code>%=</code>：余值符</li><li><code>**=</code>：幂值符</li></ul><h4 id="Ex38"><a href="#Ex38" class="headerlink" title="Ex38"></a>Ex38</h4><ol><li>列表的索引可以使用负值，相当于倒序取值</li><li><code>&#39;xxx&#39;.join(列表)</code>可以用<code>xxx</code>连接列表每项</li><li>Python的面向对象方法可理解成，以自身作为其中一个参数的函数调用</li></ol><h4 id="Ex39"><a href="#Ex39" class="headerlink" title="Ex39"></a>Ex39</h4><ol><li>字典的方法</li></ol><ul><li><code>clear()</code>：清空字典中所有元素</li><li><code>copy()</code>：复制，复制一个字典副本（新的内存）</li><li><code>dict.fromkeys(S [,v])</code>：这个是dict类型的方法，用于构造新字典。如果<code>S</code>可迭代，则迭代<code>S</code>的值作为<code>key</code>，对应的值为<code>v</code>。<code>v</code>没填默认为<code>None</code></li><li><code>get(k[,d])</code>：取值，如果字典中<code>k</code>键存在，则取<code>k</code>对应的值；否则，有<code>d</code>参数取<code>d</code>，没设<code>d</code>默认为<code>None</code></li><li><code>items()</code>：字典元素的集合（键值对集）</li><li><code>keys()</code>：字典键的集合</li><li><code>pop(k[,d])</code>：提取，如果<code>k</code>键存在，则取<code>k</code>对应的值；否则，有<code>d</code>参数取<code>d</code>，没设<code>d</code>默认为<code>None</code></li><li><code>popitem()</code>：提取键值对，后进先出</li><li><code>setdefault(k[,d])</code>：执行<code>get(k[,d])</code>，如果<code>k</code>键不存在，把<code>k</code>键的值设为<code>d</code></li><li><code>values()</code>：值的集合</li></ul><h4 id="Ex40"><a href="#Ex40" class="headerlink" title="Ex40"></a>Ex40</h4><ol><li>类的定义<code>class Xxx(object):</code>，意思为定义继承<code>object</code>的<code>Xxx</code>类型，需定义一个<code>__init__(self[, values])</code>函数作为初始化（或<code>pass</code>）</li></ol><h4 id="Ex41"><a href="#Ex41" class="headerlink" title="Ex41"></a>Ex41</h4><ol><li>一些词汇</li></ol><ul><li><code>class</code>：定义类的关键字。告诉Python创建新类型</li><li><code>object</code>：对象。最基本类型</li><li><code>instance</code>：实例。Python除元类外，都是某个类的实例</li><li><code>def</code>：定义类里边函数关键字</li><li><code>self</code>：对自身的调用。<code>class</code>里的函数都会有这个参数，指代被访问的<code>object</code>或<code>instance</code>的一个变量</li><li><code>inheritance</code>：继承。指一个<code>class</code>可以继承另一个类的特性，和父子关系类似</li><li><code>composition</code>：构建。指一个<code>class</code>可以作为另一个类的部件构建起来，像车子和车轮的关系</li><li><code>attribute</code>：属性。<code>class</code>的一个属性，来自<code>composition</code>，通常是一个变量</li><li><code>is-a</code>：用来描述一个继承关系，如<code>Salmon is-a Fish</code>，三文鱼是一种鱼</li><li><code>has-a</code>：描述一种东西是另外一些东西组成，或是有某个特征，<code>Salmon has-a mouth</code>，三文鱼有嘴（这个特征）</li></ul><h4 id="Ex42"><a href="#Ex42" class="headerlink" title="Ex42"></a>Ex42</h4><ol><li>Python中的一切都是对象，要么是类的实例，要么是元类的实例，除了<code>type</code></li></ol><h4 id="Ex43"><a href="#Ex43" class="headerlink" title="Ex43"></a>Ex43</h4><ol><li>在函数的结束时返回函数名，加上括号就可以调用了</li><li><code>getattr()</code>从某个对象中取出某个属性</li></ol><h4 id="Ex44"><a href="#Ex44" class="headerlink" title="Ex44"></a>Ex44</h4><ol><li><code>super(本类名,self)</code>允许子类中调用父类的方法或属性。多重继承时，如果调用父类方法时，方法在在多个父类中重复，Python会有算法判断该用那个父类的方法</li><li>合成有别于继承，把类的属性实例化为要合成的对象，譬如<code>self.name = Name()</code>，这时，就可以通过调<code>用self.name</code>使用<code>Name</code>类中的方法了</li><li>编码规范</li></ol><ul><li><p>编码布局</p><ul><li>缩进<ul><li>使用4空格进行分块缩进</li><li>不要空格与制表符混合使用，要么全是空格，要么全是制表符</li></ul></li><li>分行<ul><li>单行最大长度为79字符，推荐最大为72字符</li><li>长行需要拆分显示，拆分行时在运算符后进行拆分</li><li>续行使用8空格制表符（tab）</li></ul></li><li>空行<ul><li>分隔独立函数与类定义用双空行</li><li>类中的方法定义之间分隔使用单空行</li><li>使用空行分隔一些有关联的定义或函数</li><li>使用空行划分逻辑块</li></ul></li><li>字符集<ul><li>Python 2.x发行版编译时使用ASCII或Latin-1编码，3.0以上都是使用UTF-8</li><li>标识符（命名）必须使用ASCII，应该使用易读的英文</li><li>字符串文字和注释都必须使用ASCII</li><li>但对于中文注释，需要在开始处插入<code># -*- coding: utf-8 -*-</code>，字符串还需要转换成utf-8编码</li></ul></li><li>加载<ul><li>加载模块时应该分行加载，不应该<code>import xxx, yyy</code></li><li>加载单一模块中的子模块时，可以使用逗号分隔子模块，<code>from xxx import xxx, yyy</code></li><li>加载总是放在文件开始处，在模块注释文档后，在定义全局变量和模块内容前</li><li>加载包括标准类库，关联的第三方类库，本地特有的应用或类库</li><li>在多组加载之间使用空行分隔</li><li>不推荐使用相对路径加载内置包，要使用绝对包路径加载</li><li>如果<code>xxx</code>中包含<code>yyy</code>模块，可以<code>import xxx</code>，在通过<code>xxx.yyy</code>使用<code>yyy</code></li></ul></li></ul></li><li><p>表达式和语句中的空白</p><ul><li>多余的<ul><li>紧接中括号、圆括号和大括号内两侧的空白</li><li>紧接逗号、分号、冒号前的空白</li><li>紧接函数名与参数左侧括号之间的空白</li><li>紧接列表名与索引或切片左侧中括号之间的空白</li><li>在操作符周围填充，是多个操作符对齐的空白</li></ul></li><li>其他建议<ul><li>在以下操作符两边加上一个空格：赋值符（<code>=</code>）、各种增值符（<code>+=</code>，<code>-=</code>等）、判断符（<code>==</code>，<code>&lt;</code>，<code>&gt;</code>，<code>!=</code>，<code>&lt;&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>in</code>，<code>not is</code>，<code>is</code>，<code>is not</code>）、逻辑符（<code>and</code>，<code>or</code>，<code>not</code>）</li><li>对于运算符，应该在低优先级的运算符两边增加一个空格，如<code>x*y + z</code></li><li>不要在配置函数关键字参数和默认值的等号（&#x3D;）两边加空格</li><li>不提倡复合语句，不提倡多条语句写在一行</li><li>可以在<code>if</code>、<code>for</code>、<code>while</code>语句的冒号后写一个小语句，但不能写多行语句，更不推荐写成一个长行</li></ul></li></ul></li><li><p>注释</p><ul><li>提示<ul><li>错误注释代码比没有注释更糟糕。所以要保持注释更新</li><li>注释是一句话，格式要跟语言格式一致</li><li>大段的注释要有标点</li><li>请用英文写注释，除非120%肯定读代码都懂中文</li></ul></li><li>块注释<ul><li>块注释要与紧随的代码有同一缩进级别</li><li>每一行都要以井号（<code>#</code>）和一个空格开始</li></ul></li><li>行内注释<ul><li>节制使用行内注释</li><li>与语句同一行，与语句至少分隔两个空格，以井号（<code>#</code>）和一个空格开始</li><li>行内注释是不必要的，但如果需要特别注意的地方加上行内注释，会非常有用</li></ul></li><li>文档字符串<ul><li>为所有公用模块、函数、类和方法写上文档字符串</li><li>在多行文档字符串结束符<code>&quot;&quot;&quot;</code>上方增加一个空行</li><li>单行的话可以把结束符<code>&quot;&quot;&quot;</code>写在同一行</li></ul></li></ul></li><li><p>版本纪录维护<br> *  如果对代码进行了版本维护，需要增加两行。第一行为：<code>__version__ = &quot;Reversion: xxxxxxxx $&quot;</code>第二行为：<code># $Source$</code>这两句放在模块文档字符串后所有代码前，并且前后各添加一个空行</p></li><li><p>命名惯例</p><ul><li>描述性：命名样式<ul><li>通常的样式有：<ul><li><code>b</code>：单小写字母</li><li><code>B</code>：单大写字母</li><li><code>lowercase</code>：小写单词</li><li><code>lower_case_with_underscores</code>：带下划线的小写单词组</li><li><code>UPPERCASE</code>：大写单词</li><li><code>UPPER_CASE_WITH_UNDERSCORES</code>：带下划线的大写单词组</li><li><code>CapitalizeWors</code>：驼峰式（每个单词首字母大写，缩写的每个字母都要大写，如HTTP）</li><li><code>mixedCase</code>：首字母小写的驼峰式</li><li><code>Capitalize_Words_With_Underscores</code>：用下划线连接的驼峰式</li><li><code>_single_leading_underscore</code>：内部私有函数，不能通过<code>from xxx import *</code>导入</li><li><code>single_trailing_underscore_</code>：用于作为参数时与Python关键字冲突</li><li><code>__double_leading_underscore</code>：命名一个类的属性时，名称会重整。<code>Xxx</code>类含<code>__yyy</code>属性，则命名为<code>_Xxx__yyy</code></li><li>__double_leading_and_trailing_underscore__：用户控制的命名空间里的魔法对象或属性。不能创造这种命名，只能按文档使用</li></ul></li></ul></li><li>惯例的：命名约定<ul><li>切勿使用<code>l</code>（小写<code>L</code>）、<code>O</code>（大写<code>o</code>）、<code>I</code>（大写<code>i</code>）作为单字符命名</li><li>模块使用小写短名，可以使用下划线增强可读性；包名也推荐使用小写短名，但不推荐用下划线</li><li>类的命名使用驼峰式。只供内部使用的类要加上前置下划线</li><li>异常命名与类的命名方式类似，如果是错误则需要加上<code>Error</code>后缀</li><li>通过定义<code>__all__</code>防止模块输出全局变量，或是在命名前加一个下划线进行内部私有化。把全剧变量当作非公共模块</li><li>函数定义使用<code>lower_case_with_underscores</code></li><li>总是使用<code>self</code>做为实例方法的第一个参数，总是使用<code>cls</code>作为类方法的第一个参数</li><li>避免函数命名与关键字冲突的方法是在最后加一个下划线，或者可以使用非关键字的同义词</li><li>方法名和实例变量的命名与函数命名规则一致，使用<code>lower_case_with_underscores</code>；非公共函数使用一个下划线开头；避免与子类的命名冲突，可以使用两个下划线开头，再由Python整合命名</li><li>常量在模块级别定义，使用<code>UPPER_CASE_WITH_UNDERSCORES</code><br>养成对类方法和实例变量进行私有或公共的分类。如果不能肯定是该公共或是该私有，就先定义为私有的</li><li>实际上，Python并没有实质的私有概念，因为没有真实存在的私有属性。在开头加个下划线，也只是避免<code>import</code>时进行导入，实际通过<code>Xxx._yyy</code>也是可以使用的</li></ul></li><li>一些建议：<ul><li>公共方法一律不加前导下划线</li><li>如果命名与关键字冲突，则添加后缀下划线</li><li>对于简单的公共数据属性，可以使用@property进行装饰。这个只能在新式类上使用；保持函数行为无副作用，譬如不会影响缓存；不要在计算复杂操作上使用属性装饰，只要很低代价就可以调用这种属性</li><li>如果在子类继承中，不希望子类继承的属性，可以使用双下划线开头的命名方式；使用命名重整的父类要求简单的命名；命名重整会使调试或取属性魔法函数变得不方便，但命名重整的规则是有文档规范和容易实现的；可以通过改进调用方式，平衡命名重整的使用</li></ul></li></ul></li><li><p>编程建议</p><ul><li>用一种不会对Python其他实现（PyPy，Jython，IronPython，Cython，Pysco等）产生消极影响的方式进行编程</li><li>单一实例的比较不要使用<code>==</code>或<code>!=</code>运算符，应该使用<code>is</code>或<code>is not</code>进行比较。如<code>is None</code>或<code>is not None</code></li><li><code>if xxx</code>意思是<code>if xxx is not None</code></li><li>如果排序算法含有大量比较时，推荐使用以下六个比较方法：<code>__eq__</code>等于，<code>__ne__</code>不等于，<code>__lt__</code>小于，<code>__le__</code>小于等于，<code>__gt__</code>大于，<code>__ge__</code>大于等于。实际的比较运算符也是调用了以上方法</li><li>使用以类为基础的异常。必须继承<code>Exception</code>基类，添加文档注释。使用类的命名规则，如果是错误，要加上<code>error</code>后缀</li><li>当抛出一个异常时，使用<code>raise XxxError(&quot;yyy&quot;)</code>代替旧格式<code>raise XxxError, &quot;yyy&quot;</code></li><li>当捕获一个异常时，如果可以都要把具体的异常写上<code>except XxxError:</code>，而不是裸<code>except:</code></li><li>裸<code>except:</code>可以捕获<code>SystemExit</code>和<code>KeyboardInterrupt</code>异常，相当于<code>except BaseException:</code>。<code>except Exception:</code>可以捕获所有异常。</li><li>在以下场景不使用裸<code>except:</code>:知道发生了错误，要把错误打印回溯日志；使用<code>try...finally</code>子句处理<code>raise</code>抛出的异常</li><li>在<code>try:</code>子句中包含最小量代码，以避免缺陷覆盖</li><li>当上下文管理器进行不是获取或释放对象资源的调用操作时，需要通过对对象的方法或函数进行调用。<code>with xxx.yyy(): do(xxx)</code>而不是<code>with xxx: do(yyy)</code></li><li>使用字符串方法代替引用字符串模块。同一操作，字符串方法会比其他字符串处理快很多</li><li>使用<code>&#39;xxx&#39;.startswith()</code>和<code>&#39;xxx&#39;.endswith()</code>检查字符串前缀和后缀。这样更简洁，更不易出错</li><li>使用<code>isinstance()</code>进行对象类型比较。普通字符串和<code>unicode</code>字符串可以使用共同基类<code>basestring</code></li><li>对于序列(字符串，列表，元组），空队列为<code>False</code>。所以不要使用长度为0进行判空，而是直接使用<code>if not xxx:</code>进行判空</li><li>字符串后不要加空格，因为一般会看不出来，而且会被一些编辑器删掉</li><li>不要使用<code>is</code>和<code>==</code>比较布尔值</li><li>Python标准库没有提供函数注释，因为怕形成一种过早的约定和特定的注解样式。建议自行发掘适合自身的注解方式</li></ul></li></ul><h4 id="Ex46"><a href="#Ex46" class="headerlink" title="Ex46"></a>Ex46</h4><p>项目框架</p><blockquote><p><code>projects\</code>  </p><blockquote><p><code>proj_hello\（项目名）</code></p><blockquote><p><code>setup.py（安装文件）</code></p><p><code>NAME\（任意命名）</code></p><blockquote><p><code>__init__.py</code></p></blockquote><p><code>bin\</code><br><code>docs\</code><br><code>tests\</code></p><blockquote><p><code>NAME_test.py</code><br><code>__init__.py</code></p></blockquote></blockquote></blockquote></blockquote><p>对项目执行测试要在项目名下级执行nosetests</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>STUDY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PYTHON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法</title>
    <link href="/2013/11/22/2013-11-22-markdown-syntax/"/>
    <url>/2013/11/22/2013-11-22-markdown-syntax/</url>
    
    <content type="html"><![CDATA[<p><strong>强调格式</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*italic*</span>   <span class="hljs-strong">**bold**</span> :<br></code></pre></td></tr></table></figure><p><em>italic</em>   <strong>bold</strong> </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">_italic_</span>   <span class="hljs-emphasis">__bold__</span> :<br></code></pre></td></tr></table></figure><p><em>italic</em>   <strong>bold</strong></p><!-- excerpt --><hr><p><strong>链接（标题选填）</strong></p><p>内联：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[例子](http:<span class="hljs-regexp">//u</span>rl.com/ <span class="hljs-string">&quot;标题&quot;</span>):<br></code></pre></td></tr></table></figure><p><a href="http://ghold.net/" title="ghold.net">例子</a></p><p>索引方式标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[例子][<span class="hljs-built_in">id</span>]. 这样，在文档的其他地方定义以下格式:<br>[<span class="hljs-built_in">id</span>]: http://example.com/  <span class="hljs-string">&quot;标题&quot;</span><br></code></pre></td></tr></table></figure><p><a href="http://ghold.net/" title="ghold.net">例子</a></p><hr><p><strong>图像（标题选填）</strong></p><p>内联：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![alt <span class="hljs-built_in">text</span>](<span class="hljs-regexp">/路径/img</span>.jpg <span class="hljs-string">&quot;标题&quot;</span>):<br></code></pre></td></tr></table></figure><p><img src="/assets/img/2013_11_22/404.png" alt="alt text" title="列子"></p><p>索引方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!<span class="hljs-selector-attr">[alt text]</span><span class="hljs-selector-attr">[id]</span>. 这样，在文档的其他地方定义以下格式:  <br><span class="hljs-selector-attr">[id]</span>: /路径/<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.jpg</span> <span class="hljs-string">&quot;标题&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/assets/img/2013_11_22/404.png" alt="alt text" title="例子">  </p><hr><p><strong>头标签</strong></p><p>setext方式：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">一级头标签</span><br><span class="hljs-section">========</span><br></code></pre></td></tr></table></figure><h1 id="一级头标签"><a href="#一级头标签" class="headerlink" title="一级头标签"></a>一级头标签</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">二级头标签</span><br><span class="hljs-section">--------</span><br></code></pre></td></tr></table></figure><h2 id="二级头标签"><a href="#二级头标签" class="headerlink" title="二级头标签"></a>二级头标签</h2><p>atx方式(后续的#可以选填)：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级头标签 #<br></code></pre></td></tr></table></figure><h1 id="一级头标签-1"><a href="#一级头标签-1" class="headerlink" title="一级头标签"></a>一级头标签</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">## 二级头标签 ##<br></code></pre></td></tr></table></figure><h2 id="二级头标签-1"><a href="#二级头标签-1" class="headerlink" title="二级头标签"></a>二级头标签</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">###### 六级头标签<br></code></pre></td></tr></table></figure><h6 id="六级头标签"><a href="#六级头标签" class="headerlink" title="六级头标签"></a>六级头标签</h6><hr><p><strong>列表</strong></p><p>有序的，没带段落：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>  Foo<br><span class="hljs-bullet">2.</span>  Bar<br></code></pre></td></tr></table></figure><ol><li>Foo</li><li>Bar</li></ol><p>无序的，带段落：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">*   A <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br>    With multiple <span class="hljs-built_in">paragraphs</span>.<br>*   Bar<br></code></pre></td></tr></table></figure><ul><li>A list item.<br>With multiple paragraphs.</li><li>Bar</li></ul><p>可以进行内嵌：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span>   Abacus<br><span class="hljs-bullet">    *</span> answer<br><span class="hljs-bullet">*</span>   Bubbles<br><span class="hljs-bullet">    1.</span>  bunk<br><span class="hljs-bullet">    2.</span>  bupkis<br><span class="hljs-bullet">        *</span> BELITTLER<br><span class="hljs-bullet">    3.</span> burper<br><span class="hljs-bullet">*</span>   Cunning<br></code></pre></td></tr></table></figure><ul><li>Abacus<ul><li>answer</li></ul></li><li>Bubbles<ol><li>bunk</li><li>bupkis<ul><li>BELITTLER</li></ul></li><li>burper</li></ol></li><li>Cunning</li></ul><hr><p>块引用</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="language-javascript">邮件形式的尖括号</span><br><span class="hljs-meta">&gt;</span> <span class="language-javascript">一般用于块引用</span><br><span class="hljs-meta">&gt;</span><br><span class="hljs-meta">&gt;</span> <span class="language-javascript">&gt; 而且可以多次引用进行内嵌</span><br><span class="hljs-meta">&gt;</span><br><span class="hljs-meta">&gt;</span> <span class="language-javascript">#### 在块中用头标签</span><br><span class="hljs-meta">&gt;</span> <br><span class="hljs-meta">&gt;</span> <span class="language-javascript">* 可以引用一个列表</span><br><span class="hljs-meta">&gt;</span> <span class="language-javascript">* 等等</span><br></code></pre></td></tr></table></figure><blockquote><p>邮件形式的尖括号<br>一般用于块引用</p><blockquote><p>而且可以多次引用进行内嵌</p></blockquote><h4 id="在块中用头标签"><a href="#在块中用头标签" class="headerlink" title="在块中用头标签"></a>在块中用头标签</h4><ul><li>可以引用一个列表</li><li>等等</li></ul></blockquote><hr><p><strong>代码标签</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`&lt;code&gt;` 块通过反引号定义<br>可以使用`` `反引号` ``在块中包含字面上的反引号<br></code></pre></td></tr></table></figure><p><code>&lt;code&gt;</code></p><p><code>‘反引号’</code></p><hr><p><strong>预格式化代码块</strong></p><p>在每一行前增加至少4个空格或一个tab，产生预格式化代码块。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">预测试代码块<br></code></pre></td></tr></table></figure><hr><p><strong>水平线</strong></p><p>三个以上的破折号或型号产生水平线：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">***</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span><br></code></pre></td></tr></table></figure><hr><p><strong>手动换行</strong></p><p>在每行结束时增加2个以上的空格可以手动换行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">玫瑰是红色的,  <br>紫罗兰是紫色的<br></code></pre></td></tr></table></figure><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TECHNIQUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MARKDOWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作总结</title>
    <link href="/2013/10/12/2013-10-12-job-summary/"/>
    <url>/2013/10/12/2013-10-12-job-summary/</url>
    
    <content type="html"><![CDATA[<p>之前的六个月一直在断断续续地做一个名为OneKeySql的测试工具项目。主要开发工作由我自己来搞，协助完成与推广由小组的其他成员抽空闲时间来帮忙。</p><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>这个小项目的初衷是优化个人工作，减少重复的数据输入。母项目是公司内部的一个重要系统，通过三年的研发累积了复杂的业务操作流程。而我们测试小组中也累积了各种各样的测试数据，其中以Oracle的数据插入操作为主。</p><p>OneKeySql通过使用模板+标签形式，代替繁杂的手工操作，使测试用例绑定特定的模板与标签配置，最终实现最少的操作达到运行测试用例的目标。</p><!-- excerpt --><p>OnekeySql的最后也是通过Oracle提供的Oci接口实现插入数据库操作，所以优先实现的如何更好地代替手工配置操作。</p><hr><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>主要思想内核实际在7月左右就完成了，后来3个月由于一些感情生活的变化，影响了开发与推广的进度，预估从10月开始会重新把提交量跟上。</p><h4 id="实现的功能："><a href="#实现的功能：" class="headerlink" title="实现的功能："></a>实现的功能：</h4><ol><li>模板+标签模式。利用数据库数据结构固定的特征，建立模板；变化部分利用标签代替，增加动态可配置性  </li><li>可视界面。利用pyqt库组建了一组可视界面，通过补充标签和点击操作即可实现用例插入</li><li>标签引用。模板配置过程中可以相互引用标签，减少配置模板时的操作</li><li>自增组件。可保证id等字段唯一，而且引用方便</li><li>多进程操作。操作后会进入后台进程操作。</li></ol><p>实现了的功能主要是围绕这最初的优化目标进行的，但同时也有很多问题：</p><h4 id="存在问题："><a href="#存在问题：" class="headerlink" title="存在问题："></a>存在问题：</h4><ol><li>数据维护问题。方便的数据操作背后是繁重的配置问题。事实上，维护数据花费的时间与编码时间差不多</li><li>公司模式的接入性。公司测试推行QTP自动化测试，如何通过QTP调用工具的功能也是现今急需解决的（上级要求）</li><li>初始配置问题。初始配置现在还需要每个用户自定义一份，一直在考虑使用服务端分配的方式进行配置</li><li>文档保全问题。文档基本没有</li></ol><p>以上仅列举了此工具目前的一些情况。</p><hr><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>从开发到小范围使用的情况来看，工具的局限性还是相当明显。只适合大量逻辑性的数据插入操作，在外部推广是相当困难的。</p><h4 id="未来的方向："><a href="#未来的方向：" class="headerlink" title="未来的方向："></a>未来的方向：</h4><ol><li>按照上级要求，开发QTP可用的接口，初步讨论结果是cmd命令行</li><li>把插入操作与配置分配放入服务器。客户端提供操作与接口服务</li><li>适当学习文档编写技巧，把文档保全了</li><li>如何使配置更简便，这是遇到最难的问题，还需要思考一下方法</li></ol><p>编程开发我也只是半路出家，自己读着文档来摸索每一个组件、每一个库如何使用。没有利用这个博客记录开发中的点滴是这个小项目的遗憾。以这篇小结作为一个新的开始，以完成项目为目标，不断学习，不断记录，不断改变。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PROJECT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PYTHON SUMMARY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eric5自定义光标样式</title>
    <link href="/2013/07/09/2013-07-09-customize-Eric-cursor-style/"/>
    <url>/2013/07/09/2013-07-09-customize-Eric-cursor-style/</url>
    
    <content type="html"><![CDATA[<p>最近在使用eric-ide写Python，突然想把编辑器editor的界面样式改变一下。通过内置的配置项很容易就可以做出仿Linux的用户界面。连接是我使用的syntax_highlighting_Python3样式，直接导入可以看到效果。其余的配置需要自行修改editor style和user interface。</p><p>过程中有个比较郁闷的事情，就是光标的颜色问题。从白色背景换成黑色背景，我以为是只要改变编辑器的前景色为白色，光标会自动变更成白色，而实际上是不可以实现的。我通过google查询类似“eric cursor color”等等的关键字，均没有什么好结果。下面介绍一种简单修改eric5光标的方法：</p><p>进入Configure-&gt;Editor-&gt;Style，这里有个Caret选项，默认是关闭的。打开后的效果相当于网页中的hover效果，移上去时会加亮。我把caretline的背景改为黑色，前景改为白色，自定义光标的效果就出来了。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TECHNIQUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ERIC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tesseract识别验证码</title>
    <link href="/2013/06/25/2013-06-25-use-tesseract-to-identify-verification-code/"/>
    <url>/2013/06/25/2013-06-25-use-tesseract-to-identify-verification-code/</url>
    
    <content type="html"><![CDATA[<p>最近在折腾一个玩意：验证码识别。起因是部门推自动化测试，而公司软件统一登录入口有个验证码输入框。虽然可以让维护人员改成固定或屏蔽掉（现在还真屏蔽了-_-），不过我还是选择了折腾一下把它破解。</p><p>架构：</p><p><strong>eric5+python3.3+pillow2.0.0+pyocr0.1.2+tesseract3.02+cowboxer1.02+windows</strong></p><p>最近半年在接触python，一直使用eric，挺不错。当然不是很精通eric，譬如还不会debug功能怎么用。本次开发使用了流行的开源光学识别库tesseract，本人能力有限，不讨论底层的东西，只说说我对它的使用。Pyocr是连接python和tesseract的桥梁，其实有更好的python-tesseract项目，待会讲到pyocr时再说理由。</p><!-- excerpt --><hr><h3 id="今天的主角："><a href="#今天的主角：" class="headerlink" title="今天的主角："></a>今天的主角：</h3><p><img src="/assets/img/2013_06_25/1.jpg" alt="alt text" title="原始验证码"></p><p>相对那些又斜体又加横线甚至还有中文的图来说，本文主角属简单的角色。不过要追求完美表现，在这里使用pillow对其进行一点修饰。岔开一下话题，pillow是PIL（python图像库）在python3.3的优化兼容版，也是非常强大。我把主角转换为灰度图，在把亮度增强为2.5倍，设定灰度的界为200，高于设为白色，低于设为黑色，去掉边框，化妆后的图：</p><p><img src="/assets/img/2013_06_25/2.jpg" alt="alt text" title="转换后"></p><h3 id="这里有个注意点："><a href="#这里有个注意点：" class="headerlink" title="这里有个注意点："></a>这里有个注意点：</h3><ul><li>图片大小。原图只有96×30大小，在之后训练traineddata时比较恶心，建议尽量放大点（这里放大了5倍）</li><li>保存质量。开始时不懂这个属性，导致保存的图会出现灰色的斑点，影响识别质量。后来在google上查找“PIL如何保存高质量图”时找到了答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">im.save(mImgFile, <span class="hljs-string">&#x27;JPEG&#x27;</span>, quality = <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>使用tesseract自带的eng. Traineddata进行识别时会出现不同程度错判，譬如会出现特殊符号、无法判断出结果。先来解决第一个问题。根据我拿到的验证码规律，是由数字和小写英文字母组成，所以我觉得自行训练一个traineddata。Traineddata是提供给tesseract进行光学识别使用的，自行训练的traineddata可提高特定类似字体的识别准确率。</p><hr><p>开始时我参考这篇文章进行操作，对快速入门非常有用。下面简述我的过程：</p><ol><li><p>选取训练集和测试集</p><p> 由于要识别的主角比较简单，我大概选择了50个图片，分4批：6、12、24、8，其中8时测试集</p></li><li><p>生成训练集box</p><p> 开始时我跟着参考文章走，结果发现一个现象，有些图片无论如何都无法产生box，或是如果自行添加box，在训练时也会报错。这个问题我一直以为是tesseract的主观意识（就是bug了）。我把这些图片列为Bad Imgs。</p><p> 直至看到一篇文章上提到了一下关于tesseract3的一个特性参数psm。如果安装了tesseract3，可以在cmd或者shell中输入tesseract查看。这个特性有11个参数，我没有根究默认是什么参数，反正如果时一列字符串建议选择7。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tesseract eng.ver.001.jpg eng.ver.001 -l eng –psm 7 batch.nochop makebox<br></code></pre></td></tr></table></figure><p> 如果后期生成了test. Traineddata，也可以使用</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tesseract eng.ver.001.jpg eng.ver.001 -l eng –psm 7 batch.nochop makebox<br></code></pre></td></tr></table></figure><p> 为了懒惰，自己已经写成py文件了</p></li><li><p>修改box</p><p> 体力活，开始时没有放大图片，修改时简直可以让视力降低几百度。使用cowboxer打开box文件，调整框框的大小和对应的字符。具体查看cowboxer的帮助</p></li><li><p>训练box，产生tr文件</p></li></ol><div class="code-wrapper"><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">tesseract eng.ver.001.jpg eng.ver.001 –psm 7 nobatch box.train<br></code></pre></td></tr></table></figure>每个box执行一次。注意，这里也要加上psm参数，不然可能会报错。</code></pre><ol start="5"><li><p>产生字符集</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unicharset_extractor eng.ver.001.tr eng.ver.002.tr eng.ver.003.tr<br></code></pre></td></tr></table></figure><p> 让tesseract知道可以识别什么字符  </p></li><li><p>生成inttemp（图像原型）、shapetable和pffmtable（字符出现次数）文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mftraining -U unicharset -O test.unicharset eng.ver.001.tr eng.ver.002.tr eng.ver.003.tr<br></code></pre></td></tr></table></figure><p> 输出几个生成训练集必须的文件</p><p> <strong>这步遇到了一个问题，参看文章（已丢失），但这篇文章是直接摘抄googlecode里的描述翻译了一下，没有给出解决办法。以下是笔者的解决方法：</strong></p><ol><li><p>需要一个合适的命名。Tesseract的文档中强调了图像的命名格式——[lang].[fontname].exp[num].tif，并不是毫无意义的，其中fontname字段的存在最为重要。验证方式在第4步的执行中输出font为ver</p></li><li><p>需要一个font_properties文件。开始时由于命名问题，一直不知道网上说这个文件要配置的Font是啥。其实就是简单的把ver 0 0 0 0 0和回车加上，保存为无-BOM UTF-8 UNIX换行符即可。</p></li></ol></li><li><p>生成normproto文件（具体也不清楚干啥的）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cntraining eng.ver.001.tr eng.ver.002.tr eng.ver.003.tr<br></code></pre></td></tr></table></figure></li><li><p>把6、7出现的文件的文件名改成test.前缀，见参考文章</p></li><li><p>合成test. traineddata</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">combine_tessdata test.<br></code></pre></td></tr></table></figure><p> 还是为了懒惰，4-9步已合成一个py</p></li><li><p>循环移上步骤不断修正test.traineddata</p></li></ol><p>最后，主角回归，使用pyocr对测试集进行识别。选择pyocr的一个重要原因是，pyocr和python-tesseract都不支持python3.3。我尝试过对python-tesseract的源码进行编译python3.3的版本，可惜水平不够，只能失败告终。而pyocr源码比较简单，只是判断识别码的话足够了，而且对python3.3的兼容性优化几步搞掂。在这个小项目期间还发现了pyocr不支持psm参数，自行添加上了。</p><p>结果令人满意，测试集的准确率达到100%。实际上用在自动化测试中也是没发现问题（当然，人家都屏蔽了-_-）</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TECHNIQUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PYTHON TESSERACT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>评论显示方式改进</title>
    <link href="/2012/02/24/2012-02-24-comments-show-better/"/>
    <url>/2012/02/24/2012-02-24-comments-show-better/</url>
    
    <content type="html"><![CDATA[<p>之前的版本其实是当鼠标移进（mouseenter）文章时，评论瞬间转变为该文章的评论，自己感觉会略显突然，用户体验也不好。再低调点的做法，当然是稍加隐藏啦。</p><p><strong>目标</strong>：点击滚动条的浮标时，弹出评论入口。</p><p><strong>难点</strong>：点击浮标时同时要获取左侧文章的信息，以便确定入口的目的地。</p><!-- excerpt --><p><strong>分析</strong>：</p><p>滚动条是使用JQuery-UI-slider生成的，内置功能强大。不过我暂时没发现解决难点的方法（如果有内置的方法请指导），所以自己折腾出另一种方法实现。</p><p>滚动条长度为100，步长为1；内容为文章列表，每篇文章长度不一，文章数量不定，但结构一致。我尝试把滚动条抽象为点集，内容列表抽象为线段集；明显无论点的位置如何，总会找到一条线段包含这个点（毕竟自己是学数学的，稍微找回点信心）。解决的方向有了，还需要一种实现的方式。</p><p>滚动条是垂直的，我选择了top这个属性确定点的位置和线段两端的位置。JQuery自带只有等于或不等于两种选择器，而现在需要的是点的位置在线段之间，也就是说JQuery自带的选择器中不能实现。纠结了一天后，我在网上发现了以下的方法，原文地址：<a href="http://james.padolsey.com/javascript/extending-jquerys-selector-capabilities/">Extending jQuery’s selector capabilities</a>。作者通过扩展JQuery选择器的方式，实现了大于、小于的逻辑选择。</p><p>最终的实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">extend</span>($.expr[<span class="hljs-string">&#x27;:&#x27;</span>],&#123;<br>  <span class="hljs-attr">top</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">a,i,m</span>) &#123;<br>    <span class="hljs-keyword">if</span>(( $(a).<span class="hljs-title function_">offset</span>().<span class="hljs-property">top</span> – <span class="hljs-number">10</span>) &lt;= m[<span class="hljs-number">3</span>]<br>            &amp;&amp; ( $(a).<span class="hljs-title function_">next</span>(a).<span class="hljs-title function_">offset</span>().<span class="hljs-property">top</span> – <span class="hljs-number">10</span> ) &gt; m[<span class="hljs-number">3</span>] )&#123;<br>            <span class="hljs-keyword">return</span> $(a);<br>        &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后只需要调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;.blog_bg:top(浮标位置)&#x27;</span>)<br></code></pre></td></tr></table></figure><p>轻松把与浮标同一水平的文章选择出来了。</p><p>总结：我猜这是一个蛋疼的功能。</p><blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TECHNIQUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JQUERY</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
